{
  "version": 3,
  "sources": ["../../node_modules/@apollo/src/react/context/ApolloContext.ts", "../../node_modules/@apollo/src/react/context/ApolloProvider.tsx", "../../node_modules/@apollo/src/react/hooks/useApolloClient.ts", "../../node_modules/@apollo/src/react/hooks/useLazyQuery.ts", "../../node_modules/@apollo/src/react/hooks/internal/useDeepMemo.ts", "../../node_modules/@apollo/src/react/hooks/internal/useRenderGuard.ts", "../../node_modules/@apollo/src/react/hooks/internal/__use.ts", "../../node_modules/@apollo/src/react/hooks/internal/wrapHook.ts", "../../node_modules/@apollo/src/react/internal/cache/FragmentReference.ts", "../../node_modules/@apollo/src/react/internal/cache/QueryReference.ts", "../../node_modules/@apollo/src/react/internal/cache/SuspenseCache.ts", "../../node_modules/@apollo/src/react/internal/cache/getSuspenseCache.ts", "../../node_modules/@apollo/src/react/internal/index.ts", "../../node_modules/@apollo/src/react/hooks/internal/useIsomorphicLayoutEffect.ts", "../../node_modules/@apollo/src/react/hooks/useSyncExternalStore.ts", "../../node_modules/@apollo/src/react/hooks/useMutation.ts", "../../node_modules/@apollo/src/react/hooks/useQuery.ts", "../../node_modules/@apollo/src/react/hooks/constants.ts", "../../node_modules/@apollo/src/react/hooks/useSubscription.ts", "../../node_modules/@apollo/src/react/hooks/useReactiveVar.ts", "../../node_modules/@apollo/src/react/hooks/useFragment.ts", "../../node_modules/@apollo/src/react/hooks/useSuspenseQuery.ts", "../../node_modules/@apollo/src/react/hooks/internal/validateSuspenseHookOptions.ts", "../../node_modules/@apollo/src/react/hooks/useBackgroundQuery.ts", "../../node_modules/@apollo/src/react/hooks/useSuspenseFragment.ts", "../../node_modules/@apollo/src/react/hooks/useLoadableQuery.ts", "../../node_modules/@apollo/src/react/hooks/useQueryRefHandlers.ts", "../../node_modules/@apollo/src/react/hooks/useReadQuery.ts", "../../node_modules/@apollo/src/react/query-preloader/createQueryPreloader.ts", "../../node_modules/@apollo/src/react/index.ts"],
  "sourcesContent": ["import type * as ReactTypes from \"react\";\nimport * as React from \"react\";\n\nimport type { ApolloClient } from \"@apollo/client\";\nimport type {\n  HookWrappers,\n  wrapperSymbol,\n} from \"@apollo/client/react/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nexport interface ApolloContextValue {\n  client?: ApolloClient;\n  [wrapperSymbol]?: HookWrappers;\n}\n\n// To make sure Apollo Client doesn't create more than one React context\n// (which can lead to problems like having an Apollo Client instance added\n// in one context, then attempting to retrieve it from another different\n// context), a single Apollo context is created and tracked in global state.\nconst contextKey = Symbol.for(\"__APOLLO_CONTEXT__\");\n\nexport function getApolloContext(): ReactTypes.Context<ApolloContextValue> {\n  invariant(\n    \"createContext\" in React,\n    \"Invoking `getApolloContext` in an environment where `React.createContext` is not available.\\n\" +\n      \"The Apollo Client functionality you are trying to use is only available in React Client Components.\\n\" +\n      'Please make sure to add \"use client\" at the top of your file.\\n' +\n      // TODO: change to React documentation once React documentation contains information about Client Components\n      \"For more information, see https://nextjs.org/docs/getting-started/react-essentials#client-components\"\n  );\n\n  let context = (React.createContext as any)[\n    contextKey\n  ] as React.Context<ApolloContextValue>;\n  if (!context) {\n    Object.defineProperty(React.createContext, contextKey, {\n      value: (context = React.createContext<ApolloContextValue>({})),\n      enumerable: false,\n      writable: false,\n      configurable: true,\n    });\n    context.displayName = \"ApolloContext\";\n  }\n  return context;\n}\n", "import type * as ReactTypes from \"react\";\nimport * as React from \"react\";\n\nimport type { ApolloClient } from \"@apollo/client\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport { getApolloContext } from \"./ApolloContext.js\";\n\nexport declare namespace ApolloProvider {\n  interface Props {\n    client: ApolloClient;\n    children: ReactTypes.ReactNode | ReactTypes.ReactNode[] | null;\n  }\n}\n\nexport const ApolloProvider: ReactTypes.FC<ApolloProvider.Props> = ({\n  client,\n  children,\n}) => {\n  const ApolloContext = getApolloContext();\n  const parentContext = React.useContext(ApolloContext);\n\n  const context = React.useMemo(() => {\n    return {\n      ...parentContext,\n      client: client || parentContext.client,\n    };\n  }, [parentContext, client]);\n\n  invariant(\n    context.client,\n    \"ApolloProvider was not passed a client instance. Make \" +\n      'sure you pass in your client via the \"client\" prop.'\n  );\n\n  return (\n    <ApolloContext.Provider value={context}>{children}</ApolloContext.Provider>\n  );\n};\n", "import * as React from \"react\";\n\nimport type { ApolloClient } from \"@apollo/client\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport { getApolloContext } from \"../context/ApolloContext.js\";\n\n/**\n * @example\n *\n * ```jsx\n * import { useApolloClient } from \"@apollo/client\";\n *\n * function SomeComponent() {\n *   const client = useApolloClient();\n *   // `client` is now set to the `ApolloClient` instance being used by the\n *   // application (that was configured using something like `ApolloProvider`)\n * }\n * ```\n *\n * @returns The `ApolloClient` instance being used by the application.\n */\nexport function useApolloClient(override?: ApolloClient): ApolloClient {\n  const context = React.useContext(getApolloContext());\n  const client = override || context.client;\n  invariant(\n    !!client,\n    'Could not find \"client\" in the context or passed in as an option. ' +\n      \"Wrap the root component in an <ApolloProvider>, or pass an ApolloClient \" +\n      \"instance in via options.\"\n  );\n\n  return client;\n}\n", "import type { TypedDocumentNode } from \"@graphql-typed-document-node/core\";\nimport { equal } from \"@wry/equality\";\nimport type { DocumentNode } from \"graphql\";\nimport * as React from \"react\";\n\nimport type {\n  ApolloClient,\n  DataState,\n  DefaultContext,\n  ErrorLike,\n  ErrorPolicy,\n  GetDataState,\n  InternalTypes,\n  MaybeMasked,\n  ObservableQuery,\n  OperationVariables,\n  RefetchWritePolicy,\n  SubscribeToMoreFunction,\n  UpdateQueryMapFn,\n  WatchQueryFetchPolicy,\n} from \"@apollo/client\";\nimport { NetworkStatus } from \"@apollo/client\";\nimport type {\n  DocumentationTypes as UtilityDocumentationTypes,\n  NoInfer,\n  VariablesOption,\n} from \"@apollo/client/utilities/internal\";\nimport { maybeDeepFreeze } from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport { useRenderGuard } from \"./internal/index.js\";\nimport { useDeepMemo } from \"./internal/useDeepMemo.js\";\nimport { useIsomorphicLayoutEffect } from \"./internal/useIsomorphicLayoutEffect.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\nexport declare namespace useLazyQuery {\n  import _self = useLazyQuery;\n  export interface Options<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > {\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#fetchPolicy:member} */\n    fetchPolicy?: WatchQueryFetchPolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#nextFetchPolicy:member} */\n    nextFetchPolicy?:\n      | WatchQueryFetchPolicy\n      | ((\n          this: ApolloClient.WatchQueryOptions<TData, TVariables>,\n          currentFetchPolicy: WatchQueryFetchPolicy,\n          context: InternalTypes.NextFetchPolicyContext<TData, TVariables>\n        ) => WatchQueryFetchPolicy);\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#refetchWritePolicy:member} */\n    refetchWritePolicy?: RefetchWritePolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#errorPolicy:member} */\n    errorPolicy?: ErrorPolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#pollInterval:member} */\n    pollInterval?: number;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#notifyOnNetworkStatusChange:member} */\n    notifyOnNetworkStatusChange?: boolean;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#returnPartialData:member} */\n    returnPartialData?: boolean;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#skipPollAttempt:member} */\n    skipPollAttempt?: () => boolean;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#client:member} */\n    client?: ApolloClient;\n  }\n  namespace DocumentationTypes {\n    namespace useLazyQuery {\n      export interface Options<\n        TData = unknown,\n        TVariables extends OperationVariables = OperationVariables,\n      > extends _self.Options<TData, TVariables> {}\n    }\n  }\n\n  namespace Base {\n    export interface Result<TData, TVariables extends OperationVariables> {\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#startPolling:member} */\n      startPolling: (pollInterval: number) => void;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#stopPolling:member} */\n      stopPolling: () => void;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#subscribeToMore:member} */\n      subscribeToMore: SubscribeToMoreFunction<TData, TVariables>;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#updateQuery:member} */\n      updateQuery: (mapFn: UpdateQueryMapFn<TData, TVariables>) => void;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#refetch:member} */\n      refetch: (\n        variables?: Partial<TVariables>\n      ) => Promise<ApolloClient.QueryResult<MaybeMasked<TData>>>;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#fetchMore:member} */\n      fetchMore: <\n        TFetchData = TData,\n        TFetchVars extends OperationVariables = TVariables,\n      >(\n        fetchMoreOptions: ObservableQuery.FetchMoreOptions<\n          TData,\n          TVariables,\n          TFetchData,\n          TFetchVars\n        >\n      ) => Promise<ApolloClient.QueryResult<MaybeMasked<TFetchData>>>;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#client:member} */\n      client: ApolloClient;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#observable:member} */\n      observable: ObservableQuery<TData, TVariables>;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#previousData:member} */\n      previousData?: MaybeMasked<TData>;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#error:member} */\n      error?: ErrorLike;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#loading:member} */\n      loading: boolean;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#networkStatus:member} */\n      networkStatus: NetworkStatus;\n    }\n  }\n\n  export type Result<\n    TData,\n    TVariables extends OperationVariables,\n    TStates extends\n      DataState<TData>[\"dataState\"] = DataState<TData>[\"dataState\"],\n  > = Base.Result<TData, TVariables> &\n    (\n      | ({\n          /**\n           * If `true`, the associated lazy query has been executed.\n           *\n           * @docGroup 2. Network info\n           */\n          called: true;\n\n          /** {@inheritDoc @apollo/client!QueryResultDocumentation#variables:member} */\n          variables: TVariables;\n        } & GetDataState<MaybeMasked<TData>, TStates>)\n      | {\n          /**\n           * If `true`, the associated lazy query has been executed.\n           *\n           * @docGroup 2. Network info\n           */\n          called: false;\n\n          /** {@inheritDoc @apollo/client!QueryResultDocumentation#variables:member} */\n          variables: Partial<TVariables>;\n\n          /** {@inheritDoc @apollo/client!QueryResultDocumentation#data:member} */\n          data: undefined;\n          /** {@inheritDoc @apollo/client!QueryResultDocumentation#dataState:member} */\n          dataState: \"empty\";\n        }\n    );\n\n  namespace DocumentationTypes {\n    namespace useLazyQuery {\n      export interface Result<TData, TVariables extends OperationVariables>\n        extends Base.Result<TData, TVariables>,\n          UtilityDocumentationTypes.DataState<TData>,\n          UtilityDocumentationTypes.VariableOptions<TVariables> {\n        /**\n         * If `true`, the associated lazy query has been executed.\n         *\n         * @docGroup 2. Network info\n         */\n        called: boolean;\n      }\n    }\n  }\n\n  export type ExecOptions<\n    TVariables extends OperationVariables = OperationVariables,\n  > = {\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#context:member} */\n    context?: DefaultContext;\n  } & VariablesOption<TVariables>;\n\n  namespace DocumentationTypes {\n    namespace useLazyQuery {\n      export interface ExecOptions<TVariables extends OperationVariables>\n        extends UtilityDocumentationTypes.VariableOptions<TVariables> {\n        /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#context:member} */\n        context?: DefaultContext;\n      }\n    }\n  }\n\n  export type ResultTuple<\n    TData,\n    TVariables extends OperationVariables,\n    TStates extends\n      DataState<TData>[\"dataState\"] = DataState<TData>[\"dataState\"],\n  > = [\n    execute: ExecFunction<TData, TVariables>,\n    result: useLazyQuery.Result<TData, TVariables, TStates>,\n  ];\n\n  export type ExecFunction<TData, TVariables extends OperationVariables> = (\n    ...args: {} extends TVariables ?\n      [options?: useLazyQuery.ExecOptions<TVariables>]\n    : [options: useLazyQuery.ExecOptions<TVariables>]\n  ) => ObservableQuery.ResultPromise<ApolloClient.QueryResult<TData>>;\n\n  namespace DocumentationTypes {\n    namespace useLazyQuery {\n      export import ResultTuple = _self.ResultTuple;\n    }\n  }\n\n  namespace DocumentationTypes {\n    /** {@inheritDoc @apollo/client/react!useLazyQuery:function(1)} */\n    export function useLazyQuery<\n      TData = unknown,\n      TVariables extends OperationVariables = OperationVariables,\n    >(\n      query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n      options: useLazyQuery.Options<TData, TVariables>\n    ): useLazyQuery.ResultTuple<TData, TVariables>;\n  }\n}\n\n// The following methods, when called will execute the query, regardless of\n// whether the useLazyQuery execute function was called before.\nconst EAGER_METHODS = [\n  \"refetch\",\n  \"fetchMore\",\n  \"updateQuery\",\n  \"startPolling\",\n  \"stopPolling\",\n  \"subscribeToMore\",\n] as const;\n\n/**\n * A hook for imperatively executing queries in an Apollo application, e.g. in response to user interaction.\n *\n * > Refer to the [Queries - Manual execution with useLazyQuery](https://www.apollographql.com/docs/react/data/queries#manual-execution-with-uselazyquery) section for a more in-depth overview of `useLazyQuery`.\n *\n * @example\n *\n * ```jsx\n * import { gql } from \"@apollo/client\";\n * import { useLazyQuery } from \"@apollo/client/react\";\n *\n * const GET_GREETING = gql`\n *   query GetGreeting($language: String!) {\n *     greeting(language: $language) {\n *       message\n *     }\n *   }\n * `;\n *\n * function Hello() {\n *   const [loadGreeting, { called, loading, data }] = useLazyQuery(GET_GREETING, {\n *     variables: { language: \"english\" },\n *   });\n *   if (called && loading) return <p>Loading ...</p>;\n *   if (!called) {\n *     return <button onClick={() => loadGreeting()}>Load greeting</button>;\n *   }\n *   return <h1>Hello {data.greeting.message}!</h1>;\n * }\n * ```\n *\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - Default options to control how the query is executed.\n * @returns A tuple in the form of `[execute, result]`\n */\nexport function useLazyQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useLazyQuery.Options<NoInfer<TData>, NoInfer<TVariables>> & {\n    returnPartialData: true;\n  }\n): useLazyQuery.ResultTuple<\n  TData,\n  TVariables,\n  \"empty\" | \"complete\" | \"streaming\" | \"partial\"\n>;\n\n/** {@inheritDoc @apollo/client/react!useLazyQuery:function(1)} */\nexport function useLazyQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useLazyQuery.Options<NoInfer<TData>, NoInfer<TVariables>> & {\n    returnPartialData: boolean;\n  }\n): useLazyQuery.ResultTuple<\n  TData,\n  TVariables,\n  \"empty\" | \"complete\" | \"streaming\" | \"partial\"\n>;\n\n/** {@inheritDoc @apollo/client/react!useLazyQuery:function(1)} */\nexport function useLazyQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: useLazyQuery.Options<NoInfer<TData>, NoInfer<TVariables>>\n): useLazyQuery.ResultTuple<\n  TData,\n  TVariables,\n  \"empty\" | \"complete\" | \"streaming\"\n>;\n\nexport function useLazyQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n  TStates extends DataState<TData>[\"dataState\"] = DataState<TData>[\"dataState\"],\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: useLazyQuery.Options<NoInfer<TData>, NoInfer<TVariables>>\n): useLazyQuery.ResultTuple<TData, TVariables, TStates> {\n  const client = useApolloClient(options?.client);\n  const previousDataRef = React.useRef<TData>(undefined);\n  const resultRef = React.useRef<ObservableQuery.Result<TData>>(undefined);\n  const stableOptions = useDeepMemo(() => options, [options]);\n  const calledDuringRender = useRenderGuard();\n\n  function createObservable() {\n    return client.watchQuery({\n      ...options,\n      query,\n      initialFetchPolicy: options?.fetchPolicy,\n      fetchPolicy: \"standby\",\n    } as ApolloClient.WatchQueryOptions<TData, TVariables>);\n  }\n\n  const [currentClient, setCurrentClient] = React.useState(client);\n  const [observable, setObservable] = React.useState(createObservable);\n\n  if (currentClient !== client) {\n    setCurrentClient(client);\n    setObservable(createObservable());\n  }\n\n  // TODO: Revisit after we have RxJS in place. We should be able to use\n  // observable.getCurrentResult() (or equivalent) to get these values which\n  // will hopefully alleviate the need for us to use refs to track these values.\n  const updateResult = React.useCallback(\n    (result: ObservableQuery.Result<TData>, forceUpdate: () => void) => {\n      const previousData = resultRef.current?.data;\n\n      if (previousData && !equal(previousData, result.data)) {\n        previousDataRef.current = previousData as TData;\n      }\n\n      resultRef.current = result;\n\n      forceUpdate();\n    },\n    []\n  );\n\n  const observableResult = useSyncExternalStore(\n    React.useCallback(\n      (forceUpdate) => {\n        const subscription = observable.subscribe((result) => {\n          if (!equal(resultRef.current, result)) {\n            updateResult(result, forceUpdate);\n          }\n        });\n\n        return () => {\n          subscription.unsubscribe();\n        };\n      },\n      [observable, updateResult]\n    ),\n    () => resultRef.current || initialResult,\n    () => initialResult\n  );\n\n  // We use useMemo here to make sure the eager methods have a stable identity.\n  const eagerMethods = React.useMemo(() => {\n    const eagerMethods: Record<string, any> = {};\n    for (const key of EAGER_METHODS) {\n      eagerMethods[key] = function (...args: any[]) {\n        invariant(\n          resultRef.current,\n          \"useLazyQuery: '%s' cannot be called before executing the query.\",\n          key\n        );\n\n        // @ts-expect-error this is just to generic to type\n        return observable[key](...args);\n      };\n    }\n\n    return eagerMethods as Pick<\n      useLazyQuery.Result<TData, TVariables>,\n      (typeof EAGER_METHODS)[number]\n    >;\n  }, [observable]);\n\n  React.useEffect(() => {\n    const updatedOptions: Partial<ObservableQuery.Options<TData, TVariables>> =\n      {\n        query,\n        errorPolicy: stableOptions?.errorPolicy,\n        refetchWritePolicy: stableOptions?.refetchWritePolicy,\n        returnPartialData: stableOptions?.returnPartialData,\n        notifyOnNetworkStatusChange: stableOptions?.notifyOnNetworkStatusChange,\n        nextFetchPolicy: options?.nextFetchPolicy,\n        skipPollAttempt: options?.skipPollAttempt,\n      };\n\n    // Wait to apply the changed fetch policy until after the execute\n    // function has been called. The execute function will handle setting the\n    // the fetch policy away from standby for us when called for the first time.\n    if (\n      observable.options.fetchPolicy !== \"standby\" &&\n      stableOptions?.fetchPolicy\n    ) {\n      updatedOptions.fetchPolicy = stableOptions.fetchPolicy;\n    }\n\n    observable.applyOptions(updatedOptions);\n  }, [\n    query,\n    observable,\n    stableOptions,\n    // Ensure inline functions don't suffer from stale closures by checking for\n    // these deps separately. @wry/equality doesn't compare function identity\n    // so `stableOptions` isn't updated when using inline functions.\n    options?.nextFetchPolicy,\n    options?.skipPollAttempt,\n  ]);\n\n  const execute: useLazyQuery.ExecFunction<TData, TVariables> =\n    React.useCallback(\n      (...args) => {\n        invariant(\n          !calledDuringRender(),\n          \"useLazyQuery: 'execute' should not be called during render. To start a query during render, use the 'useQuery' hook.\"\n        );\n\n        const [executeOptions] = args;\n\n        let fetchPolicy = observable.options.fetchPolicy;\n\n        if (fetchPolicy === \"standby\") {\n          fetchPolicy = observable.options.initialFetchPolicy;\n        }\n\n        return observable.reobserve({\n          fetchPolicy,\n          // If `variables` is not given, reset back to empty variables by\n          // ensuring the key exists in options\n          variables: executeOptions?.variables,\n          context: executeOptions?.context ?? {},\n        });\n      },\n      [observable, calledDuringRender]\n    );\n\n  const executeRef = React.useRef(execute);\n  useIsomorphicLayoutEffect(() => {\n    executeRef.current = execute;\n  });\n\n  const stableExecute = React.useCallback<typeof execute>(\n    (...args) => executeRef.current(...args),\n    []\n  );\n\n  const result = React.useMemo(() => {\n    const { partial, ...result } = observableResult;\n\n    return {\n      ...eagerMethods,\n      ...result,\n      client,\n      previousData: previousDataRef.current,\n      variables: observable.variables,\n      observable,\n      called: !!resultRef.current,\n    };\n  }, [client, observableResult, eagerMethods, observable]);\n\n  return [stableExecute, result as any];\n}\n\nconst initialResult: ObservableQuery.Result<any> = maybeDeepFreeze({\n  data: undefined,\n  dataState: \"empty\",\n  loading: false,\n  networkStatus: NetworkStatus.ready,\n  partial: true,\n});\n", "import { equal } from \"@wry/equality\";\nimport type { DependencyList } from \"react\";\nimport * as React from \"react\";\n\nexport function useDeepMemo<TValue>(\n  memoFn: () => TValue,\n  deps: DependencyList\n) {\n  const ref = React.useRef<{ deps: DependencyList; value: TValue }>(void 0);\n  if (!ref.current || !equal(ref.current.deps, deps)) {\n    ref.current = { value: memoFn(), deps };\n  }\n  return ref.current.value;\n}\n", "import * as React from \"react\";\n\nlet Ctx: React.Context<null>;\n\nfunction noop() {}\nexport function useRenderGuard() {\n  if (!Ctx) {\n    // we want the intialization to be lazy because `createContext` would error on import in a RSC\n    Ctx = React.createContext(null);\n  }\n\n  return React.useCallback(\n    /**\n     * @returns true if the hook was called during render\n     */ () => {\n      const orig = console.error;\n      try {\n        console.error = noop;\n\n        /**\n         * `useContext` can be called conditionally during render, so this is safe.\n         * (Also, during render we would want to throw as a reaction to this anyways, so it\n         * wouldn't even matter if we got the order of hooks mixed up...)\n         *\n         * They cannot however be called outside of Render, and that's what we're testing here.\n         *\n         * Different versions of React have different behaviour on an invalid hook call:\n         *\n         * React 16.8 - 17: throws an error\n         * https://github.com/facebook/react/blob/2b93d686e359c7afa299e2ec5cf63160a32a1155/packages/react/src/ReactHooks.js#L18-L26\n         *\n         * React 18 & 19: `console.error` in development, then `resolveDispatcher` returns `null` and a member access on `null` throws.\n         * https://github.com/facebook/react/blob/58e8304483ebfadd02a295339b5e9a989ac98c6e/packages/react/src/ReactHooks.js#L28-L35\n         */\n        React[\"useContext\" /* hide this from the linter */](Ctx);\n        return true;\n      } catch (e) {\n        return false;\n      } finally {\n        console.error = orig;\n      }\n    },\n    []\n  );\n}\n", "import * as React from \"react\";\n\nimport { decoratePromise } from \"@apollo/client/utilities/internal\";\n\ntype Use = <T>(promise: Promise<T>) => T;\n// Prevent webpack from complaining about our feature detection of the\n// use property of the React namespace, which is expected not\n// to exist when using current stable versions, and that's fine.\nconst useKey = \"use\" as keyof typeof React;\nconst realHook = React[useKey] as Use | undefined;\n\n// This is named with two underscores to allow this hook to evade typical rules of\n// hooks (i.e. it can be used conditionally)\nexport const __use =\n  realHook ||\n  function __use<TValue>(promise: Promise<TValue>) {\n    const decoratedPromise = decoratePromise(promise);\n\n    switch (decoratedPromise.status) {\n      case \"pending\":\n        throw decoratedPromise;\n      case \"rejected\":\n        throw decoratedPromise.reason;\n      case \"fulfilled\":\n        return decoratedPromise.value;\n    }\n  };\n", "import * as React from \"react\";\n\nimport type { ApolloClient, InternalTypes } from \"@apollo/client\";\nimport type { ObservableQuery } from \"@apollo/client\";\nimport type { createQueryPreloader } from \"@apollo/client/react\";\nimport type {\n  useBackgroundQuery,\n  useFragment,\n  useQuery,\n  useQueryRefHandlers,\n  useReadQuery,\n  useSuspenseFragment,\n  useSuspenseQuery,\n} from \"@apollo/client/react\";\nimport { wrapperSymbol } from \"@apollo/client/react/internal\";\n\n// direct import to avoid circular dependency\nimport { getApolloContext } from \"../../context/ApolloContext.js\";\n\ntype FunctionSignature<T> =\n  T extends (...args: infer A) => infer R ? (...args: A) => R : never;\n\ninterface WrappableHooks {\n  createQueryPreloader: FunctionSignature<typeof createQueryPreloader>;\n  useQuery: FunctionSignature<typeof useQuery>;\n  useSuspenseQuery: FunctionSignature<typeof useSuspenseQuery>;\n  useSuspenseFragment: FunctionSignature<typeof useSuspenseFragment>;\n  useBackgroundQuery: FunctionSignature<typeof useBackgroundQuery>;\n  useReadQuery: FunctionSignature<typeof useReadQuery>;\n  useFragment: FunctionSignature<typeof useFragment>;\n  useQueryRefHandlers: FunctionSignature<typeof useQueryRefHandlers>;\n}\n\n/**\n * @internal\n * Can be used to correctly type the [Symbol.for(\"apollo.hook.wrappers\")] property of\n * `QueryManager`, to override/wrap hook functionality.\n */\nexport type HookWrappers = {\n  [K in keyof WrappableHooks]?: (\n    originalHook: WrappableHooks[K]\n  ) => WrappableHooks[K];\n};\n\ninterface QueryManagerWithWrappers extends InternalTypes.QueryManager {\n  [wrapperSymbol]?: HookWrappers;\n}\n\n/**\n * @internal\n *\n * Makes an Apollo Client hook \"wrappable\".\n * That means that the Apollo Client instance can expose a \"wrapper\" that will be\n * used to wrap the original hook implementation with additional logic.\n * @example\n *\n * ```tsx\n * // this is already done in `@apollo/client` for all wrappable hooks (see `WrappableHooks`)\n * // following this pattern\n * function useQuery() {\n *   return wrapHook('useQuery', _useQuery, options.client)(query, options);\n * }\n * function _useQuery(query, options) {\n *   // original implementation\n * }\n *\n * // this is what a library like `@apollo/client-react-streaming` would do\n * class ApolloClientWithStreaming extends ApolloClient {\n *   constructor(options) {\n *     super(options);\n *     this.queryManager[Symbol.for(\"apollo.hook.wrappers\")] = {\n *       useQuery: (original) => (query, options) => {\n *         console.log(\"useQuery was called with options\", options);\n *         return original(query, options);\n *       }\n *     }\n *   }\n * }\n *\n * // this will now log the options and then call the original `useQuery`\n * const client = new ApolloClientWithStreaming({ ... });\n * useQuery(query, { client });\n * ```\n */\nexport function wrapHook<Hook extends (...args: any[]) => any>(\n  hookName: keyof WrappableHooks,\n  useHook: Hook,\n  clientOrObsQuery: ObservableQuery<any> | ApolloClient\n): Hook {\n  // Priority-wise, the later entries in this array wrap\n  // previous entries and could prevent them (and in the end,\n  // even the original hook) from running\n  const wrapperSources = [\n    (\n      clientOrObsQuery as unknown as {\n        // both `ApolloClient` and `ObservableQuery` have a `queryManager` property\n        // but they're both `private`, so we have to cast around for a bit here.\n        queryManager: QueryManagerWithWrappers;\n      }\n    )[\"queryManager\"],\n    // if we are a hook (not `preloadQuery`), we are guaranteed to be inside of\n    // a React render and can use context\n    hookName.startsWith(\"use\") ?\n      // eslint-disable-next-line react-hooks/rules-of-hooks\n      React.useContext(getApolloContext())\n    : undefined,\n  ];\n\n  let wrapped = useHook;\n  for (const source of wrapperSources) {\n    const wrapper = source?.[wrapperSymbol]?.[hookName];\n    if (wrapper) {\n      wrapped = wrapper(wrapped) as Hook;\n    }\n  }\n\n  return wrapped;\n}\n", "import { equal } from \"@wry/equality\";\nimport type { Observable, Subscription } from \"rxjs\";\n\nimport type { ApolloClient, OperationVariables } from \"@apollo/client\";\nimport type { MaybeMasked } from \"@apollo/client/masking\";\nimport type { DecoratedPromise } from \"@apollo/client/utilities/internal\";\nimport {\n  createFulfilledPromise,\n  decoratePromise,\n} from \"@apollo/client/utilities/internal\";\n\nimport type { FragmentKey } from \"./types.js\";\n\ntype FragmentRefPromise<TData> = DecoratedPromise<TData>;\ntype Listener<TData> = (promise: FragmentRefPromise<TData>) => void;\n\ninterface FragmentReferenceOptions {\n  autoDisposeTimeoutMs?: number;\n  onDispose?: () => void;\n}\n\nexport class FragmentReference<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n> {\n  public readonly observable: Observable<\n    ApolloClient.WatchFragmentResult<TData>\n  >;\n  public readonly key: FragmentKey = {};\n  public promise!: FragmentRefPromise<MaybeMasked<TData>>;\n\n  private resolve: ((result: MaybeMasked<TData>) => void) | undefined;\n  private reject: ((error: unknown) => void) | undefined;\n\n  private subscription!: Subscription;\n  private listeners = new Set<Listener<MaybeMasked<TData>>>();\n  private autoDisposeTimeoutId?: NodeJS.Timeout;\n\n  private references = 0;\n\n  constructor(\n    client: ApolloClient,\n    watchFragmentOptions: ApolloClient.WatchFragmentOptions<\n      TData,\n      TVariables\n    > & {\n      from: string;\n    },\n    options: FragmentReferenceOptions\n  ) {\n    this.dispose = this.dispose.bind(this);\n    this.handleNext = this.handleNext.bind(this);\n    this.handleError = this.handleError.bind(this);\n\n    this.observable = client.watchFragment(watchFragmentOptions);\n\n    if (options.onDispose) {\n      this.onDispose = options.onDispose;\n    }\n\n    const diff = this.getDiff(client, watchFragmentOptions);\n\n    // Start a timer that will automatically dispose of the query if the\n    // suspended resource does not use this fragmentRef in the given time. This\n    // helps prevent memory leaks when a component has unmounted before the\n    // query has finished loading.\n    const startDisposeTimer = () => {\n      if (!this.references) {\n        this.autoDisposeTimeoutId = setTimeout(\n          this.dispose,\n          options.autoDisposeTimeoutMs ?? 30_000\n        );\n      }\n    };\n\n    this.promise =\n      diff.complete ?\n        createFulfilledPromise(diff.result)\n      : this.createPendingPromise();\n    this.subscribeToFragment();\n\n    this.promise.then(startDisposeTimer, startDisposeTimer);\n  }\n\n  listen(listener: Listener<MaybeMasked<TData>>) {\n    this.listeners.add(listener);\n\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n\n  retain() {\n    this.references++;\n    clearTimeout(this.autoDisposeTimeoutId);\n    let disposed = false;\n\n    return () => {\n      if (disposed) {\n        return;\n      }\n\n      disposed = true;\n      this.references--;\n\n      setTimeout(() => {\n        if (!this.references) {\n          this.dispose();\n        }\n      });\n    };\n  }\n\n  private dispose() {\n    this.subscription.unsubscribe();\n  }\n\n  private onDispose() {\n    // noop. overridable by options\n  }\n\n  private subscribeToFragment() {\n    this.subscription = this.observable.subscribe(\n      this.handleNext.bind(this),\n      this.handleError.bind(this)\n    );\n    // call `onDispose` when the subscription is finalized, either because it is\n    // unsubscribed as a consequence of a `dispose` call or because the\n    // ObservableQuery completes because of a `ApolloClient.stop()` call.\n    this.subscription.add(this.onDispose);\n  }\n\n  private handleNext(result: ApolloClient.WatchFragmentResult<TData>) {\n    switch (this.promise.status) {\n      case \"pending\": {\n        if (result.complete) {\n          return this.resolve?.(result.data);\n        }\n\n        this.deliver(this.promise);\n        break;\n      }\n      case \"fulfilled\": {\n        // This can occur when we already have a result written to the cache and\n        // we subscribe for the first time. We create a fulfilled promise in the\n        // constructor with a value that is the same as the first emitted value\n        // so we want to skip delivering it.\n        if (equal(this.promise.value, result.data)) {\n          return;\n        }\n\n        this.promise =\n          result.complete ?\n            createFulfilledPromise(result.data)\n          : this.createPendingPromise();\n\n        this.deliver(this.promise);\n      }\n    }\n  }\n\n  private handleError(error: unknown) {\n    this.reject?.(error);\n  }\n\n  private deliver(promise: FragmentRefPromise<MaybeMasked<TData>>) {\n    this.listeners.forEach((listener) => listener(promise));\n  }\n\n  private createPendingPromise() {\n    return decoratePromise(\n      new Promise<MaybeMasked<TData>>((resolve, reject) => {\n        this.resolve = resolve;\n        this.reject = reject;\n      })\n    );\n  }\n\n  private getDiff<TData, TVariables extends OperationVariables>(\n    client: ApolloClient,\n    options: ApolloClient.WatchFragmentOptions<TData, TVariables> & {\n      from: string;\n    }\n  ) {\n    const { cache } = client;\n    const { from, fragment, fragmentName } = options;\n\n    const diff = cache.diff<TData, TVariables>({\n      ...options,\n      query: cache[\"getFragmentDoc\"](\n        client[\"transform\"](fragment),\n        fragmentName\n      ),\n      returnPartialData: true,\n      id: from,\n      optimistic: true,\n    });\n\n    return {\n      ...diff,\n      result: client[\"queryManager\"].maskFragment({\n        fragment,\n        fragmentName,\n        data: diff.result,\n      }) as MaybeMasked<TData>,\n    };\n  }\n}\n", "import { equal } from \"@wry/equality\";\nimport type { Subscription } from \"rxjs\";\nimport { filter } from \"rxjs\";\n\nimport type {\n  ApolloClient,\n  DataState,\n  ObservableQuery,\n  OperationVariables,\n} from \"@apollo/client\";\nimport type { MaybeMasked } from \"@apollo/client/masking\";\nimport type { DecoratedPromise } from \"@apollo/client/utilities/internal\";\nimport {\n  createFulfilledPromise,\n  createRejectedPromise,\n  decoratePromise,\n} from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport type { QueryKey } from \"./types.js\";\n\ntype QueryRefPromise<\n  TData,\n  TStates extends DataState<TData>[\"dataState\"],\n> = DecoratedPromise<ObservableQuery.Result<MaybeMasked<TData>, TStates>>;\n\ntype Listener<TData, TStates extends DataState<TData>[\"dataState\"]> = (\n  promise: QueryRefPromise<TData, TStates>\n) => void;\n\nconst QUERY_REFERENCE_SYMBOL: unique symbol = Symbol.for(\n  \"apollo.internal.queryRef\"\n);\nconst PROMISE_SYMBOL: unique symbol = Symbol.for(\"apollo.internal.refPromise\");\ndeclare const QUERY_REF_BRAND: unique symbol;\ndeclare const PRELOADED_QUERY_REF_BRAND: unique symbol;\n/**\n * A `QueryReference` is an opaque object returned by `useBackgroundQuery`.\n * A child component reading the `QueryReference` via `useReadQuery` will\n * suspend until the promise resolves.\n */\nexport interface QueryRef<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n  TStates extends DataState<TData>[\"dataState\"] = \"complete\" | \"streaming\",\n> {\n  /** @internal */\n  [QUERY_REF_BRAND]?(variables: TVariables): { data: TData; states: TStates };\n}\n\n/**\n * @internal\n * For usage in internal helpers only.\n */\ninterface WrappedQueryRef<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n  TStates extends DataState<TData>[\"dataState\"] = \"complete\" | \"streaming\",\n> extends QueryRef<TData, TVariables, TStates> {\n  /** @internal */\n  readonly [QUERY_REFERENCE_SYMBOL]: InternalQueryReference<TData, TStates>;\n  /** @internal */\n  [PROMISE_SYMBOL]: QueryRefPromise<TData, TStates>;\n}\n\n/**\n * {@inheritDoc @apollo/client/react!QueryRef:interface}\n */\nexport interface PreloadedQueryRef<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n  TStates extends DataState<TData>[\"dataState\"] = \"complete\" | \"streaming\",\n> extends QueryRef<TData, TVariables, TStates> {\n  /** @internal */\n  [PRELOADED_QUERY_REF_BRAND]: typeof PRELOADED_QUERY_REF_BRAND;\n}\n\ninterface InternalQueryReferenceOptions {\n  onDispose?: () => void;\n  autoDisposeTimeoutMs?: number;\n}\n\nexport function wrapQueryRef<\n  TData,\n  TVariables extends OperationVariables,\n  TStates extends DataState<TData>[\"dataState\"],\n>(internalQueryRef: InternalQueryReference<TData, TStates>) {\n  return {\n    [QUERY_REFERENCE_SYMBOL]: internalQueryRef,\n    [PROMISE_SYMBOL]: internalQueryRef.promise,\n  } as WrappedQueryRef<TData, TVariables, TStates>;\n}\n\nexport function assertWrappedQueryRef<\n  TData,\n  TVariables extends OperationVariables,\n  TStates extends DataState<TData>[\"dataState\"],\n>(\n  queryRef: QueryRef<TData, TVariables, TStates>\n): asserts queryRef is WrappedQueryRef<TData, TVariables, TStates>;\n\nexport function assertWrappedQueryRef<\n  TData,\n  TVariables extends OperationVariables,\n  TStates extends DataState<TData>[\"dataState\"],\n>(\n  queryRef: QueryRef<TData, TVariables, TStates> | undefined | null\n): asserts queryRef is\n  | WrappedQueryRef<TData, TVariables, TStates>\n  | undefined\n  | null;\n\nexport function assertWrappedQueryRef<\n  TData,\n  TVariables extends OperationVariables,\n  TStates extends DataState<TData>[\"dataState\"],\n>(queryRef: QueryRef<TData, TVariables, TStates> | undefined | null) {\n  invariant(\n    !queryRef || QUERY_REFERENCE_SYMBOL in queryRef,\n    \"Expected a QueryRef object, but got something else instead.\"\n  );\n}\n\nexport function getWrappedPromise<\n  TData,\n  TStates extends DataState<TData>[\"dataState\"],\n>(queryRef: WrappedQueryRef<TData, any, TStates>) {\n  const internalQueryRef = unwrapQueryRef(queryRef);\n\n  return internalQueryRef.promise.status === \"fulfilled\" ?\n      internalQueryRef.promise\n    : queryRef[PROMISE_SYMBOL];\n}\n\nexport function unwrapQueryRef<\n  TData,\n  TStates extends DataState<TData>[\"dataState\"],\n>(\n  queryRef: WrappedQueryRef<TData, any, TStates>\n): InternalQueryReference<TData, TStates>;\n\nexport function unwrapQueryRef<\n  TData,\n  TStates extends DataState<TData>[\"dataState\"],\n>(\n  queryRef: Partial<WrappedQueryRef<TData, any, TStates>>\n): undefined | InternalQueryReference<TData, TStates>;\n\nexport function unwrapQueryRef<\n  TData,\n  TStates extends DataState<TData>[\"dataState\"],\n>(queryRef: Partial<WrappedQueryRef<TData, any, TStates>>) {\n  return queryRef[QUERY_REFERENCE_SYMBOL];\n}\n\nexport function updateWrappedQueryRef<\n  TData,\n  TStates extends DataState<TData>[\"dataState\"],\n>(\n  queryRef: WrappedQueryRef<TData, any, TStates>,\n  promise: QueryRefPromise<TData, TStates>\n) {\n  queryRef[PROMISE_SYMBOL] = promise;\n}\n\nconst OBSERVED_CHANGED_OPTIONS = [\n  \"context\",\n  \"errorPolicy\",\n  \"fetchPolicy\",\n  \"refetchWritePolicy\",\n  \"returnPartialData\",\n] as const;\n\ntype ObservedOptions = Pick<\n  ApolloClient.WatchQueryOptions,\n  (typeof OBSERVED_CHANGED_OPTIONS)[number]\n>;\n\nexport class InternalQueryReference<\n  TData = unknown,\n  TStates extends DataState<TData>[\"dataState\"] = DataState<TData>[\"dataState\"],\n> {\n  public result!: ObservableQuery.Result<MaybeMasked<TData>, TStates>;\n  public readonly key: QueryKey = {};\n  public readonly observable: ObservableQuery<TData>;\n\n  public promise!: QueryRefPromise<TData, TStates>;\n\n  private subscription!: Subscription;\n  private listeners = new Set<Listener<TData, TStates>>();\n  private autoDisposeTimeoutId?: NodeJS.Timeout;\n\n  private resolve:\n    | ((result: ObservableQuery.Result<MaybeMasked<TData>, TStates>) => void)\n    | undefined;\n  private reject: ((error: unknown) => void) | undefined;\n\n  private references = 0;\n  private softReferences = 0;\n\n  constructor(\n    observable: ObservableQuery<TData, any>,\n    options: InternalQueryReferenceOptions\n  ) {\n    this.handleNext = this.handleNext.bind(this);\n    this.dispose = this.dispose.bind(this);\n    this.observable = observable;\n\n    if (options.onDispose) {\n      this.onDispose = options.onDispose;\n    }\n\n    this.setResult();\n    this.subscribeToQuery();\n\n    // Start a timer that will automatically dispose of the query if the\n    // suspended resource does not use this queryRef in the given time. This\n    // helps prevent memory leaks when a component has unmounted before the\n    // query has finished loading.\n    const startDisposeTimer = () => {\n      if (!this.references) {\n        this.autoDisposeTimeoutId = setTimeout(\n          this.dispose,\n          options.autoDisposeTimeoutMs ?? 30_000\n        );\n      }\n    };\n\n    // We wait until the request has settled to ensure we don't dispose of the\n    // query ref before the request finishes, otherwise we would leave the\n    // promise in a pending state rendering the suspense boundary indefinitely.\n    this.promise.then(startDisposeTimer, startDisposeTimer);\n  }\n\n  get disposed() {\n    return this.subscription.closed;\n  }\n\n  get watchQueryOptions() {\n    return this.observable.options;\n  }\n\n  reinitialize() {\n    const { observable } = this;\n\n    const originalFetchPolicy = this.watchQueryOptions.fetchPolicy;\n    const avoidNetworkRequests =\n      originalFetchPolicy === \"no-cache\" || originalFetchPolicy === \"standby\";\n\n    try {\n      if (avoidNetworkRequests) {\n        observable.applyOptions({ fetchPolicy: \"standby\" });\n      } else {\n        observable.reset();\n        observable.applyOptions({ fetchPolicy: \"cache-first\" });\n      }\n\n      if (!avoidNetworkRequests) {\n        this.setResult();\n      }\n      this.subscribeToQuery();\n    } finally {\n      observable.applyOptions({ fetchPolicy: originalFetchPolicy });\n    }\n  }\n\n  retain() {\n    this.references++;\n    clearTimeout(this.autoDisposeTimeoutId);\n    let disposed = false;\n\n    return () => {\n      if (disposed) {\n        return;\n      }\n\n      disposed = true;\n      this.references--;\n\n      setTimeout(() => {\n        if (!this.references) {\n          this.dispose();\n        }\n      });\n    };\n  }\n\n  softRetain() {\n    this.softReferences++;\n    let disposed = false;\n\n    return () => {\n      // Tracking if this has already been called helps ensure that\n      // multiple calls to this function won't decrement the reference\n      // counter more than it should. Subsequent calls just result in a noop.\n      if (disposed) {\n        return;\n      }\n\n      disposed = true;\n      this.softReferences--;\n      setTimeout(() => {\n        if (!this.softReferences && !this.references) {\n          this.dispose();\n        }\n      });\n    };\n  }\n\n  didChangeOptions(watchQueryOptions: ObservedOptions) {\n    return OBSERVED_CHANGED_OPTIONS.some(\n      (option) =>\n        option in watchQueryOptions &&\n        !equal(this.watchQueryOptions[option], watchQueryOptions[option])\n    );\n  }\n\n  applyOptions(watchQueryOptions: ObservedOptions) {\n    const { fetchPolicy: currentFetchPolicy } = this.watchQueryOptions;\n\n    // \"standby\" is used when `skip` is set to `true`. Detect when we've\n    // enabled the query (i.e. `skip` is `false`) to execute a network request.\n    if (\n      currentFetchPolicy === \"standby\" &&\n      currentFetchPolicy !== watchQueryOptions.fetchPolicy\n    ) {\n      this.initiateFetch(this.observable.reobserve(watchQueryOptions));\n    } else {\n      this.observable.applyOptions(watchQueryOptions);\n    }\n\n    return this.promise;\n  }\n\n  listen(listener: Listener<TData, TStates>) {\n    this.listeners.add(listener);\n\n    return () => {\n      this.listeners.delete(listener);\n    };\n  }\n\n  refetch(variables: OperationVariables | undefined) {\n    return this.initiateFetch(this.observable.refetch(variables));\n  }\n\n  fetchMore(options: ObservableQuery.FetchMoreOptions<TData, any, any, any>) {\n    return this.initiateFetch(this.observable.fetchMore<TData>(options));\n  }\n\n  private dispose() {\n    this.subscription.unsubscribe();\n  }\n\n  private onDispose() {\n    // noop. overridable by options\n  }\n\n  private handleNext(\n    result: ObservableQuery.Result<MaybeMasked<TData>, TStates>\n  ) {\n    switch (this.promise.status) {\n      case \"pending\": {\n        // Maintain the last successful `data` value if the next result does not\n        // have one.\n        // TODO: This can likely be removed once\n        // https://github.com/apollographql/apollo-client/issues/12667 is fixed\n        if (result.data === void 0) {\n          result.data = this.result.data;\n\n          if (result.data) {\n            result.dataState = \"complete\" as any;\n          }\n        }\n\n        if (this.shouldReject(result)) {\n          this.reject?.(result.error);\n        } else {\n          this.result = result;\n          this.resolve?.(result);\n        }\n        break;\n      }\n      default: {\n        // This occurs when switching to a result that is fully cached when this\n        // class is instantiated. ObservableQuery will run reobserve when\n        // subscribing, which delivers a result from the cache.\n        if (\n          result.data === this.result.data &&\n          result.networkStatus === this.result.networkStatus\n        ) {\n          return;\n        }\n\n        // Maintain the last successful `data` value if the next result does not\n        // have one.\n        if (result.data === void 0) {\n          result.data = this.result.data;\n        }\n\n        if (this.shouldReject(result)) {\n          this.promise = createRejectedPromise(result.error);\n          this.deliver(this.promise);\n        } else {\n          this.result = result;\n          this.promise = createFulfilledPromise(result);\n          this.deliver(this.promise);\n        }\n        break;\n      }\n    }\n  }\n\n  private deliver(promise: QueryRefPromise<TData, TStates>) {\n    this.listeners.forEach((listener) => listener(promise));\n  }\n\n  private initiateFetch(\n    returnedPromise: Promise<ApolloClient.QueryResult<MaybeMasked<TData>>>\n  ) {\n    this.promise = this.createPendingPromise();\n    this.promise.catch(() => {});\n\n    // If the data returned from the fetch is deeply equal to the data already\n    // in the cache, `handleNext` will not be triggered leaving the promise we\n    // created in a pending state forever. To avoid this situtation, we attempt\n    // to resolve the promise if `handleNext` hasn't been run to ensure the\n    // promise is resolved correctly.\n    returnedPromise\n      .then(() => {\n        // In the case of `fetchMore`, this promise is resolved before a cache\n        // result is emitted due to the fact that `fetchMore` sets a `no-cache`\n        // fetch policy and runs `cache.batch` in its `.then` handler. Because\n        // the timing is different, we accidentally run this update twice\n        // causing an additional re-render with the `fetchMore` result by\n        // itself. By wrapping in `setTimeout`, this should provide a short\n        // delay to allow the `QueryInfo.notify` handler to run before this\n        // promise is checked.\n        // See https://github.com/apollographql/apollo-client/issues/11315 for\n        // more information\n        setTimeout(() => {\n          if (this.promise.status === \"pending\") {\n            // Use the current result from the observable instead of the value\n            // resolved from the promise. This avoids issues in some cases where\n            // the raw resolved value should not be the emitted value, such as\n            // when a `fetchMore` call returns an empty array after it has\n            // reached the end of the list.\n            //\n            // See the following for more information:\n            // https://github.com/apollographql/apollo-client/issues/11642\n            this.result =\n              this.observable.getCurrentResult() as ObservableQuery.Result<\n                TData,\n                TStates\n              >;\n            this.resolve?.(this.result);\n          }\n        });\n      })\n      .catch((error) => this.reject?.(error));\n\n    return returnedPromise;\n  }\n\n  private subscribeToQuery() {\n    this.subscription = this.observable\n      .pipe(filter((result) => !equal(result, this.result)))\n      .subscribe(this.handleNext as any);\n    // call `onDispose` when the subscription is finalized, either because it is\n    // unsubscribed as a consequence of a `dispose` call or because the\n    // ObservableQuery completes because of a `ApolloClient.stop()` call.\n    this.subscription.add(this.onDispose);\n  }\n\n  private setResult() {\n    const result = this.observable.getCurrentResult() as ObservableQuery.Result<\n      TData,\n      TStates\n    >;\n\n    if (equal(result, this.result)) {\n      return;\n    }\n\n    this.result = result;\n    this.promise =\n      result.data ?\n        createFulfilledPromise(result)\n      : this.createPendingPromise();\n  }\n\n  private shouldReject(result: ObservableQuery.Result<any>) {\n    const { errorPolicy = \"none\" } = this.watchQueryOptions;\n\n    return result.error && errorPolicy === \"none\";\n  }\n\n  private createPendingPromise() {\n    return decoratePromise(\n      new Promise<ObservableQuery.Result<MaybeMasked<TData>, TStates>>(\n        (resolve, reject) => {\n          this.resolve = resolve;\n          this.reject = reject;\n        }\n      )\n    );\n  }\n}\n", "import { Trie } from \"@wry/trie\";\n\nimport type {\n  ApolloClient,\n  DataState,\n  ObservableQuery,\n  OperationVariables,\n} from \"@apollo/client\";\n\nimport { FragmentReference } from \"./FragmentReference.js\";\nimport { InternalQueryReference } from \"./QueryReference.js\";\nimport type { CacheKey, FragmentCacheKey } from \"./types.js\";\n\nexport interface SuspenseCacheOptions {\n  /**\n   * Specifies the amount of time, in milliseconds, the suspense cache will wait\n   * for a suspended component to read from the suspense cache before it\n   * automatically disposes of the query. This prevents memory leaks when a\n   * component unmounts before a suspended resource finishes loading. Increase\n   * the timeout if your queries take longer than than the specified time to\n   * prevent your queries from suspending over and over.\n   *\n   * Defaults to 30 seconds.\n   */\n  autoDisposeTimeoutMs?: number;\n}\n\nexport class SuspenseCache {\n  private queryRefs = new Trie<{ current?: InternalQueryReference }>();\n  private fragmentRefs = new Trie<{ current?: FragmentReference }>();\n\n  private options: SuspenseCacheOptions;\n\n  constructor(options: SuspenseCacheOptions = {}) {\n    this.options = options;\n  }\n\n  getQueryRef<\n    TData = unknown,\n    TStates extends\n      DataState<TData>[\"dataState\"] = DataState<TData>[\"dataState\"],\n  >(cacheKey: CacheKey, createObservable: () => ObservableQuery<TData>) {\n    const ref = this.queryRefs.lookupArray(cacheKey) as {\n      current?: InternalQueryReference<TData, TStates>;\n    };\n\n    if (!ref.current) {\n      ref.current = new InternalQueryReference(createObservable(), {\n        autoDisposeTimeoutMs: this.options.autoDisposeTimeoutMs,\n        onDispose: () => {\n          delete ref.current;\n        },\n      });\n    }\n\n    return ref.current;\n  }\n\n  getFragmentRef<TData, TVariables extends OperationVariables>(\n    cacheKey: FragmentCacheKey,\n    client: ApolloClient,\n    options: ApolloClient.WatchFragmentOptions<TData, TVariables> & {\n      from: string;\n    }\n  ) {\n    const ref = this.fragmentRefs.lookupArray(cacheKey) as {\n      current?: FragmentReference<TData, TVariables>;\n    };\n\n    if (!ref.current) {\n      ref.current = new FragmentReference(client, options, {\n        autoDisposeTimeoutMs: this.options.autoDisposeTimeoutMs,\n        onDispose: () => {\n          delete ref.current;\n        },\n      });\n    }\n\n    return ref.current;\n  }\n\n  add(cacheKey: CacheKey, queryRef: InternalQueryReference<any, any>) {\n    const ref = this.queryRefs.lookupArray(cacheKey);\n    ref.current = queryRef;\n  }\n}\n", "import type { ApolloClient } from \"@apollo/client\";\nimport type { SuspenseCacheOptions } from \"@apollo/client/react/internal\";\n\nimport { SuspenseCache } from \"./SuspenseCache.js\";\n\ndeclare module \"@apollo/client\" {\n  namespace ApolloClient {\n    interface DefaultOptions {\n      react?: {\n        suspense?: Readonly<SuspenseCacheOptions>;\n      };\n    }\n  }\n}\n\nconst suspenseCacheSymbol = Symbol.for(\"apollo.suspenseCache\");\n\nexport function getSuspenseCache(\n  client: ApolloClient & {\n    [suspenseCacheSymbol]?: SuspenseCache;\n  }\n) {\n  if (!client[suspenseCacheSymbol]) {\n    client[suspenseCacheSymbol] = new SuspenseCache(\n      client.defaultOptions.react?.suspense\n    );\n  }\n\n  return client[suspenseCacheSymbol];\n}\n", "import type { InternalTypes as ReactInternalTypes } from \"@apollo/client/react\";\nexport { getSuspenseCache } from \"./cache/getSuspenseCache.js\";\nexport type { CacheKey, FragmentKey, QueryKey } from \"./cache/types.js\";\nexport type { PreloadedQueryRef, QueryRef } from \"./cache/QueryReference.js\";\nexport {\n  assertWrappedQueryRef,\n  getWrappedPromise,\n  InternalQueryReference,\n  unwrapQueryRef,\n  updateWrappedQueryRef,\n  wrapQueryRef,\n} from \"./cache/QueryReference.js\";\nexport type { SuspenseCacheOptions } from \"./cache/SuspenseCache.js\";\nexport type HookWrappers = ReactInternalTypes.HookWrappers;\nexport const wrapperSymbol = Symbol.for(\"apollo.hook.wrappers\");\nexport type { FetchMoreFunction, RefetchFunction } from \"./types.js\";\n", "import * as React from \"react\";\n\nimport { canUseDOM } from \"@apollo/client/utilities/internal\";\n\n// use canUseDOM here instead of canUseLayoutEffect because we want to be able\n// to use useLayoutEffect in our jest tests. useLayoutEffect seems to work fine\n// in useSuspenseQuery tests, but to honor the original comment about the\n// warnings for useSyncExternalStore implementation, canUseLayoutEffect is left\n// alone.\nexport const useIsomorphicLayoutEffect =\n  canUseDOM ? React.useLayoutEffect : React.useEffect;\n", "import * as React from \"react\";\n\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport { canUseDOM } from \"@apollo/client/utilities/internal\";\nimport { maybe } from \"@apollo/client/utilities/internal/globals\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nlet didWarnUncachedGetSnapshot = false;\n\ntype RealUseSESHookType =\n  // This import depends only on the @types/use-sync-external-store package, not\n  // the actual use-sync-external-store package, which is not installed. It\n  // might be nice to get this type from React 18, but it still needs to work\n  // when only React 17 or earlier is installed.\n  typeof import(\"use-sync-external-store\").useSyncExternalStore;\n\n// Prevent webpack from complaining about our feature detection of the\n// useSyncExternalStore property of the React namespace, which is expected not\n// to exist when using React 17 and earlier, and that's fine.\nconst uSESKey = \"useSyncExternalStore\" as keyof typeof React;\nconst realHook = React[uSESKey] as RealUseSESHookType | undefined;\n\nconst isReactNative = maybe(() => navigator.product) == \"ReactNative\";\nconst usingJSDOM: boolean =\n  // Following advice found in this comment from @domenic (maintainer of jsdom):\n  // https://github.com/jsdom/jsdom/issues/1537#issuecomment-229405327\n  //\n  // Since we control the version of Jest and jsdom used when running Apollo\n  // Client tests, and that version is recent enought to include \" jsdom/x.y.z\"\n  // at the end of the user agent string, I believe this case is all we need to\n  // check. Testing for \"Node.js\" was recommended for backwards compatibility\n  // with older version of jsdom, but we don't have that problem.\n  maybe(() => navigator.userAgent.indexOf(\"jsdom\") >= 0) || false;\n\n// Our tests should all continue to pass if we remove this !usingJSDOM\n// condition, thereby allowing useLayoutEffect when using jsdom. Unfortunately,\n// if we allow useLayoutEffect, then useSyncExternalStore generates many\n// warnings about useLayoutEffect doing nothing on the server. While these\n// warnings are harmless, this !usingJSDOM condition seems to be the best way to\n// prevent them (i.e. skipping useLayoutEffect when using jsdom).\nconst canUseLayoutEffect = (canUseDOM || isReactNative) && !usingJSDOM;\n\n// Adapted from https://www.npmjs.com/package/use-sync-external-store, with\n// Apollo Client deviations called out by \"// DEVIATION ...\" comments.\n\n// When/if React.useSyncExternalStore is defined, delegate fully to it.\nexport const useSyncExternalStore: RealUseSESHookType =\n  realHook ||\n  ((subscribe, getSnapshot, getServerSnapshot) => {\n    // Read the current snapshot from the store on every render. Again, this\n    // breaks the rules of React, and only works here because of specific\n    // implementation details, most importantly that updates are\n    // always synchronous.\n    const value = getSnapshot();\n    if (\n      // DEVIATION: Using __DEV__\n      __DEV__ &&\n      !didWarnUncachedGetSnapshot &&\n      // DEVIATION: Not using Object.is because we know our snapshots will never\n      // be exotic primitive values like NaN, which is !== itself.\n      value !== getSnapshot()\n    ) {\n      didWarnUncachedGetSnapshot = true;\n      // DEVIATION: Using invariant.error instead of console.error directly.\n      invariant.error(\n        \"The result of getSnapshot should be cached to avoid an infinite loop\"\n      );\n    }\n\n    // Because updates are synchronous, we don't queue them. Instead we force a\n    // re-render whenever the subscribed state changes by updating an some\n    // arbitrary useState hook. Then, during render, we call getSnapshot to read\n    // the current value.\n    //\n    // Because we don't actually use the state returned by the useState hook, we\n    // can save a bit of memory by storing other stuff in that slot.\n    //\n    // To implement the early bailout, we need to track some things on a mutable\n    // object. Usually, we would put that in a useRef hook, but we can stash it in\n    // our useState hook instead.\n    //\n    // To force a re-render, we call forceUpdate({inst}). That works because the\n    // new object always fails an equality check.\n    const [{ inst }, forceUpdate] = React.useState({\n      inst: { value, getSnapshot },\n    });\n\n    // Track the latest getSnapshot function with a ref. This needs to be updated\n    // in the layout phase so we can access it during the tearing check that\n    // happens on subscribe.\n    if (canUseLayoutEffect) {\n      // DEVIATION: We avoid calling useLayoutEffect when !canUseLayoutEffect,\n      // which may seem like a conditional hook, but this code ends up behaving\n      // unconditionally (one way or the other) because canUseLayoutEffect is\n      // constant.\n      React.useLayoutEffect(() => {\n        Object.assign(inst, { value, getSnapshot });\n        // Whenever getSnapshot or subscribe changes, we need to check in the\n        // commit phase if there was an interleaved mutation. In concurrent mode\n        // this can happen all the time, but even in synchronous mode, an earlier\n        // effect may have mutated the store.\n        if (checkIfSnapshotChanged(inst)) {\n          // Force a re-render.\n          forceUpdate({ inst });\n        }\n        // React Hook React.useLayoutEffect has a missing dependency: 'inst'. Either include it or remove the dependency array.\n        // eslint-disable-next-line react-hooks/exhaustive-deps\n      }, [subscribe, value, getSnapshot]);\n    } else {\n      Object.assign(inst, { value, getSnapshot });\n    }\n\n    React.useEffect(() => {\n      // Check for changes right before subscribing. Subsequent changes will be\n      // detected in the subscription handler.\n      if (checkIfSnapshotChanged(inst)) {\n        // Force a re-render.\n        forceUpdate({ inst });\n      }\n\n      // Subscribe to the store and return a clean-up function.\n      return subscribe(function handleStoreChange() {\n        // TODO: Because there is no cross-renderer API for batching updates, it's\n        // up to the consumer of this library to wrap their subscription event\n        // with unstable_batchedUpdates. Should we try to detect when this isn't\n        // the case and print a warning in development?\n\n        // The store changed. Check if the snapshot changed since the last time we\n        // read from the store.\n        if (checkIfSnapshotChanged(inst)) {\n          // Force a re-render.\n          forceUpdate({ inst });\n        }\n      });\n      // React Hook React.useEffect has a missing dependency: 'inst'. Either include it or remove the dependency array.\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [subscribe]);\n\n    return value;\n  });\n\nfunction checkIfSnapshotChanged<Snapshot>({\n  value,\n  getSnapshot,\n}: {\n  value: Snapshot;\n  getSnapshot: () => Snapshot;\n}): boolean {\n  try {\n    return value !== getSnapshot();\n  } catch {\n    return true;\n  }\n}\n", "import type { TypedDocumentNode } from \"@graphql-typed-document-node/core\";\nimport { equal } from \"@wry/equality\";\nimport * as React from \"react\";\n\nimport type {\n  ApolloCache,\n  ApolloClient,\n  DefaultContext,\n  DocumentNode,\n  ErrorLike,\n  ErrorPolicy,\n  InternalRefetchQueriesInclude,\n  MaybeMasked,\n  MutationFetchPolicy,\n  MutationQueryReducersMap,\n  MutationUpdaterFunction,\n  NormalizedExecutionResult,\n  OnQueryUpdated,\n  OperationVariables,\n  Unmasked,\n} from \"@apollo/client\";\nimport type { IgnoreModifier } from \"@apollo/client/cache\";\nimport type { NoInfer, Prettify } from \"@apollo/client/utilities/internal\";\nimport {\n  mergeOptions,\n  preventUnhandledRejection,\n} from \"@apollo/client/utilities/internal\";\n\nimport { useIsomorphicLayoutEffect } from \"./internal/useIsomorphicLayoutEffect.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\n\ntype MakeRequiredVariablesOptional<\n  TVariables extends OperationVariables,\n  TConfiguredVariables extends Partial<TVariables>,\n> = Prettify<\n  {\n    [K in keyof TVariables as K extends keyof TConfiguredVariables ? K\n    : never]?: TVariables[K];\n  } & Omit<TVariables, keyof TConfiguredVariables>\n>;\n\nexport declare namespace useMutation {\n  export interface Options<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n    TCache extends ApolloCache = ApolloCache,\n    TConfiguredVariables extends Partial<TVariables> = Partial<TVariables>,\n  > {\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#optimisticResponse:member} */\n    optimisticResponse?:\n      | Unmasked<NoInfer<TData>>\n      | ((\n          vars: TVariables,\n          { IGNORE }: { IGNORE: IgnoreModifier }\n        ) => Unmasked<NoInfer<TData>> | IgnoreModifier);\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#updateQueries:member} */\n    updateQueries?: MutationQueryReducersMap<TData>;\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#refetchQueries:member} */\n    refetchQueries?:\n      | ((\n          result: NormalizedExecutionResult<Unmasked<TData>>\n        ) => InternalRefetchQueriesInclude)\n      | InternalRefetchQueriesInclude;\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#awaitRefetchQueries:member} */\n    awaitRefetchQueries?: boolean;\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#update:member} */\n    update?: MutationUpdaterFunction<TData, TVariables, TCache>;\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#onQueryUpdated:member} */\n    onQueryUpdated?: OnQueryUpdated<any>;\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#errorPolicy:member} */\n    errorPolicy?: ErrorPolicy;\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#variables:member} */\n    variables?: Partial<TVariables> & TConfiguredVariables;\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#context:member} */\n    context?: DefaultContext;\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#fetchPolicy:member} */\n    fetchPolicy?: MutationFetchPolicy;\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#keepRootFields:member} */\n    keepRootFields?: boolean;\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#client:member} */\n    client?: ApolloClient;\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#notifyOnNetworkStatusChange:member} */\n    notifyOnNetworkStatusChange?: boolean;\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#onCompleted:member} */\n    onCompleted?: (\n      data: MaybeMasked<TData>,\n      clientOptions?: Options<TData, TVariables, TCache>\n    ) => void;\n\n    /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#onError:member} */\n    onError?: (\n      error: ErrorLike,\n      clientOptions?: Options<TData, TVariables, TCache>\n    ) => void;\n  }\n\n  export interface Result<TData = unknown> {\n    /** {@inheritDoc @apollo/client!MutationResultDocumentation#data:member} */\n    data: MaybeMasked<TData> | null | undefined;\n\n    /** {@inheritDoc @apollo/client!MutationResultDocumentation#error:member} */\n    error: ErrorLike | undefined;\n\n    /** {@inheritDoc @apollo/client!MutationResultDocumentation#loading:member} */\n    loading: boolean;\n\n    /** {@inheritDoc @apollo/client!MutationResultDocumentation#called:member} */\n    called: boolean;\n\n    /** {@inheritDoc @apollo/client!MutationResultDocumentation#client:member} */\n    client: ApolloClient;\n\n    /** {@inheritDoc @apollo/client!MutationResultDocumentation#reset:member} */\n    reset: () => void;\n  }\n\n  export type ResultTuple<\n    TData,\n    TVariables extends OperationVariables,\n    TCache extends ApolloCache = ApolloCache,\n  > = [\n    mutate: MutationFunction<TData, TVariables, TCache>,\n    result: Result<TData>,\n  ];\n\n  export type MutationFunction<\n    TData,\n    TVariables extends OperationVariables,\n    TCache extends ApolloCache = ApolloCache,\n  > = (\n    ...[options]: {} extends TVariables ?\n      [\n        options?: MutationFunctionOptions<TData, TVariables, TCache> & {\n          /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#variables:member} */\n          variables?: TVariables;\n        },\n      ]\n    : [\n        options: MutationFunctionOptions<TData, TVariables, TCache> & {\n          /** {@inheritDoc @apollo/client!MutationOptionsDocumentation#variables:member} */\n          variables: TVariables;\n        },\n      ]\n  ) => Promise<ApolloClient.MutateResult<MaybeMasked<TData>>>;\n\n  export type MutationFunctionOptions<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n    TCache extends ApolloCache = ApolloCache,\n  > = Options<TData, TVariables, TCache>;\n\n  export namespace DocumentationTypes {\n    /** {@inheritDoc @apollo/client/react!useMutation:function(1)} */\n    export function useMutation<\n      TData = unknown,\n      TVariables extends OperationVariables = OperationVariables,\n    >(\n      mutation: DocumentNode | TypedDocumentNode<TData, TVariables>,\n      options?: useMutation.Options<TData, TVariables>\n    ): useMutation.ResultTuple<TData, TVariables>;\n  }\n}\n\n/**\n * > Refer to the [Mutations](https://www.apollographql.com/docs/react/data/mutations/) section for a more in-depth overview of `useMutation`.\n *\n * @example\n *\n * ```jsx\n * import { gql, useMutation } from \"@apollo/client\";\n *\n * const ADD_TODO = gql`\n *   mutation AddTodo($type: String!) {\n *     addTodo(type: $type) {\n *       id\n *       type\n *     }\n *   }\n * `;\n *\n * function AddTodo() {\n *   let input;\n *   const [addTodo, { data }] = useMutation(ADD_TODO);\n *\n *   return (\n *     <div>\n *       <form\n *         onSubmit={(e) => {\n *           e.preventDefault();\n *           addTodo({ variables: { type: input.value } });\n *           input.value = \"\";\n *         }}\n *       >\n *         <input\n *           ref={(node) => {\n *             input = node;\n *           }}\n *         />\n *         <button type=\"submit\">Add Todo</button>\n *       </form>\n *     </div>\n *   );\n * }\n * ```\n *\n * @param mutation - A GraphQL mutation document parsed into an AST by `gql`.\n * @param options - Options to control how the mutation is executed.\n * @returns A tuple in the form of `[mutate, result]`\n */\nexport function useMutation<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n  TCache extends ApolloCache = ApolloCache,\n  TConfiguredVariables extends Partial<TVariables> = {},\n>(\n  mutation: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: useMutation.Options<\n    NoInfer<TData>,\n    NoInfer<TVariables>,\n    TCache,\n    {\n      [K in keyof TConfiguredVariables]: K extends keyof TVariables ?\n        TConfiguredVariables[K]\n      : never;\n    }\n  >\n): useMutation.ResultTuple<\n  TData,\n  MakeRequiredVariablesOptional<TVariables, TConfiguredVariables>,\n  TCache\n> {\n  const client = useApolloClient(options?.client);\n  const [result, setResult] = React.useState<\n    Omit<useMutation.Result<TData>, \"reset\">\n  >(() => createInitialResult(client));\n\n  const ref = React.useRef({\n    result,\n    mutationId: 0,\n    isMounted: true,\n    client,\n    mutation,\n    options,\n  });\n\n  useIsomorphicLayoutEffect(() => {\n    Object.assign(ref.current, { client, options, mutation });\n  });\n\n  const execute = React.useCallback(\n    (\n      executeOptions: useMutation.MutationFunctionOptions<\n        TData,\n        TVariables,\n        TCache\n      > = {} as useMutation.MutationFunctionOptions<TData, TVariables, TCache>\n    ) => {\n      const { options, mutation } = ref.current;\n      const baseOptions = { ...options, mutation };\n      const client = executeOptions.client || ref.current.client;\n\n      if (!ref.current.result.loading && ref.current.isMounted) {\n        setResult(\n          (ref.current.result = {\n            loading: true,\n            error: undefined,\n            data: undefined,\n            called: true,\n            client,\n          })\n        );\n      }\n\n      const mutationId = ++ref.current.mutationId;\n      const clientOptions = mergeOptions(baseOptions, executeOptions as any);\n\n      return preventUnhandledRejection(\n        client\n          .mutate(\n            clientOptions as ApolloClient.MutateOptions<\n              TData,\n              OperationVariables\n            >\n          )\n          .then(\n            (response) => {\n              const { data, error } = response;\n\n              const onError =\n                executeOptions.onError || ref.current.options?.onError;\n\n              if (error && onError) {\n                onError(error, clientOptions);\n              }\n\n              if (mutationId === ref.current.mutationId) {\n                const result = {\n                  called: true,\n                  loading: false,\n                  data,\n                  error,\n                  client,\n                };\n\n                if (\n                  ref.current.isMounted &&\n                  !equal(ref.current.result, result)\n                ) {\n                  setResult((ref.current.result = result));\n                }\n              }\n\n              const onCompleted =\n                executeOptions.onCompleted || ref.current.options?.onCompleted;\n\n              if (!error) {\n                onCompleted?.(response.data!, clientOptions);\n              }\n\n              return response;\n            },\n            (error) => {\n              if (\n                mutationId === ref.current.mutationId &&\n                ref.current.isMounted\n              ) {\n                const result = {\n                  loading: false,\n                  error,\n                  data: void 0,\n                  called: true,\n                  client,\n                };\n\n                if (!equal(ref.current.result, result)) {\n                  setResult((ref.current.result = result));\n                }\n              }\n\n              const onError =\n                executeOptions.onError || ref.current.options?.onError;\n\n              if (onError) {\n                onError(error, clientOptions);\n              }\n\n              throw error;\n            }\n          )\n      );\n    },\n    []\n  );\n\n  const reset = React.useCallback(() => {\n    if (ref.current.isMounted) {\n      const result = createInitialResult(ref.current.client);\n      Object.assign(ref.current, { mutationId: 0, result });\n      setResult(result);\n    }\n  }, []);\n\n  React.useEffect(() => {\n    const current = ref.current;\n    current.isMounted = true;\n\n    return () => {\n      current.isMounted = false;\n    };\n  }, []);\n\n  return [execute as any, { reset, ...result }];\n}\n\nfunction createInitialResult(client: ApolloClient) {\n  return {\n    data: undefined,\n    error: undefined,\n    called: false,\n    loading: false,\n    client,\n  };\n}\n", "/**\n * Function parameters in this file try to follow a common order for the sake of\n * readability and consistency. The order is as follows:\n *\n * resultData\n * observable\n * client\n * query\n * options\n * watchQueryOptions\n * makeWatchQueryOptions\n */\n/**  */\nimport { equal } from \"@wry/equality\";\nimport * as React from \"react\";\nimport { asapScheduler, observeOn } from \"rxjs\";\n\nimport type {\n  DataState,\n  DefaultContext,\n  DocumentNode,\n  ErrorLike,\n  ErrorPolicy,\n  GetDataState,\n  InternalTypes,\n  ObservableQuery,\n  OperationVariables,\n  RefetchWritePolicy,\n  SubscribeToMoreFunction,\n  TypedDocumentNode,\n  UpdateQueryMapFn,\n  WatchQueryFetchPolicy,\n} from \"@apollo/client\";\nimport type { ApolloClient } from \"@apollo/client\";\nimport { NetworkStatus } from \"@apollo/client\";\nimport type { MaybeMasked } from \"@apollo/client/masking\";\nimport type {\n  DocumentationTypes as UtilityDocumentationTypes,\n  NoInfer,\n  VariablesOption,\n} from \"@apollo/client/utilities/internal\";\nimport {\n  maybeDeepFreeze,\n  mergeOptions,\n} from \"@apollo/client/utilities/internal\";\n\nimport type { SkipToken } from \"./constants.js\";\nimport { skipToken } from \"./constants.js\";\nimport { useDeepMemo, wrapHook } from \"./internal/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\n\nexport declare namespace useQuery {\n  import _self = useQuery;\n  export namespace Base {\n    export interface Options<\n      TData = unknown,\n      TVariables extends OperationVariables = OperationVariables,\n    > {\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#fetchPolicy:member} */\n      fetchPolicy?: WatchQueryFetchPolicy;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#nextFetchPolicy:member} */\n      nextFetchPolicy?:\n        | WatchQueryFetchPolicy\n        | ((\n            this: ApolloClient.WatchQueryOptions<TData, TVariables>,\n            currentFetchPolicy: WatchQueryFetchPolicy,\n            context: InternalTypes.NextFetchPolicyContext<TData, TVariables>\n          ) => WatchQueryFetchPolicy);\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#initialFetchPolicy:member} */\n\n      initialFetchPolicy?: WatchQueryFetchPolicy;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#refetchWritePolicy:member} */\n      refetchWritePolicy?: RefetchWritePolicy;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#errorPolicy:member} */\n      errorPolicy?: ErrorPolicy;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#pollInterval:member} */\n      pollInterval?: number;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#notifyOnNetworkStatusChange:member} */\n      notifyOnNetworkStatusChange?: boolean;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#returnPartialData:member} */\n      returnPartialData?: boolean;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#skipPollAttempt:member} */\n      skipPollAttempt?: () => boolean;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#ssr:member} */\n      ssr?: boolean;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#client:member} */\n      client?: ApolloClient;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#context:member} */\n      context?: DefaultContext;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#skip:member} */\n      skip?: boolean;\n    }\n  }\n  export type Options<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > = Base.Options<TData, TVariables> & VariablesOption<TVariables>;\n\n  export namespace DocumentationTypes {\n    namespace useQuery {\n      export interface Options<\n        TData = unknown,\n        TVariables extends OperationVariables = OperationVariables,\n      > extends Base.Options<TData, TVariables>,\n          UtilityDocumentationTypes.VariableOptions<TVariables> {}\n    }\n  }\n\n  export namespace Base {\n    export interface Result<\n      TData = unknown,\n      TVariables extends OperationVariables = OperationVariables,\n      TReturnVariables extends OperationVariables = TVariables,\n    > {\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#client:member} */\n      client: ApolloClient;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#observable:member} */\n      observable: ObservableQuery<TData, TVariables>;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#previousData:member} */\n      previousData?: MaybeMasked<TData>;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#error:member} */\n      error?: ErrorLike;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#loading:member} */\n      loading: boolean;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#networkStatus:member} */\n      networkStatus: NetworkStatus;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#startPolling:member} */\n      startPolling: (pollInterval: number) => void;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#stopPolling:member} */\n      stopPolling: () => void;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#subscribeToMore:member} */\n      subscribeToMore: SubscribeToMoreFunction<TData, TVariables>;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#updateQuery:member} */\n      updateQuery: (mapFn: UpdateQueryMapFn<TData, TVariables>) => void;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#refetch:member} */\n      refetch: (\n        variables?: Partial<TVariables>\n      ) => Promise<ApolloClient.QueryResult<MaybeMasked<TData>>>;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#variables:member} */\n      variables: TReturnVariables;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#fetchMore:member} */\n      fetchMore: <\n        TFetchData = TData,\n        TFetchVars extends OperationVariables = TVariables,\n      >(\n        fetchMoreOptions: ObservableQuery.FetchMoreOptions<\n          TData,\n          TVariables,\n          TFetchData,\n          TFetchVars\n        >\n      ) => Promise<ApolloClient.QueryResult<MaybeMasked<TFetchData>>>;\n    }\n  }\n  export type Result<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n    TStates extends\n      DataState<TData>[\"dataState\"] = DataState<TData>[\"dataState\"],\n    TReturnVariables extends OperationVariables = TVariables,\n  > = Base.Result<TData, TVariables, TReturnVariables> &\n    GetDataState<MaybeMasked<TData>, TStates>;\n\n  export namespace DocumentationTypes {\n    namespace useQuery {\n      export interface Result<\n        TData = unknown,\n        TVariables extends OperationVariables = OperationVariables,\n      > extends Base.Result<TData, TVariables>,\n          UtilityDocumentationTypes.DataState<TData> {}\n    }\n  }\n\n  export namespace DocumentationTypes {\n    /** {@inheritDoc @apollo/client/react!useQuery:function(1)} */\n    export function useQuery<\n      TData = unknown,\n      TVariables extends OperationVariables = OperationVariables,\n    >(\n      query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n      options: useQuery.Options<TData, TVariables>\n    ): useQuery.Result<TData, TVariables>;\n  }\n}\n\nconst lastWatchOptions = Symbol();\n\ninterface ObsQueryWithMeta<TData, TVariables extends OperationVariables>\n  extends ObservableQuery<TData, TVariables> {\n  [lastWatchOptions]?: Readonly<\n    ApolloClient.WatchQueryOptions<TData, TVariables>\n  >;\n}\n\ninterface InternalResult<TData> {\n  // These members are populated by getCurrentResult and setResult, and it's\n  // okay/normal for them to be initially undefined.\n  current: ObservableQuery.Result<TData>;\n  previousData?: undefined | MaybeMasked<TData>;\n\n  // Track current variables separately in case a call to e.g. `refetch(newVars)`\n  // causes an emit that is deeply equal to the current result. This lets us\n  // compare if we should force rerender due to changed variables\n  variables: OperationVariables;\n}\n\ninterface InternalState<TData, TVariables extends OperationVariables> {\n  client: ReturnType<typeof useApolloClient>;\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n  observable: ObsQueryWithMeta<TData, TVariables>;\n  resultData: InternalResult<TData>;\n}\n\n/**\n * A hook for executing queries in an Apollo application.\n *\n * To run a query within a React component, call `useQuery` and pass it a GraphQL query document.\n *\n * When your component renders, `useQuery` returns an object from Apollo Client that contains `loading`, `error`, `dataState`, and `data` properties you can use to render your UI.\n *\n * > Refer to the [Queries](https://www.apollographql.com/docs/react/data/queries) section for a more in-depth overview of `useQuery`.\n *\n * @example\n *\n * ```jsx\n * import { gql } from \"@apollo/client\";\n * import { useQuery } from \"@apollo/client/react\";\n *\n * const GET_GREETING = gql`\n *   query GetGreeting($language: String!) {\n *     greeting(language: $language) {\n *       message\n *     }\n *   }\n * `;\n *\n * function Hello() {\n *   const { loading, error, data } = useQuery(GET_GREETING, {\n *     variables: { language: \"english\" },\n *   });\n *   if (loading) return <p>Loading ...</p>;\n *   return <h1>Hello {data.greeting.message}!</h1>;\n * }\n * ```\n *\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - Options to control how the query is executed.\n * @returns Query result object\n */\nexport function useQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useQuery.Options<NoInfer<TData>, NoInfer<TVariables>> & {\n    returnPartialData: true;\n  }\n): useQuery.Result<\n  TData,\n  TVariables,\n  \"empty\" | \"complete\" | \"streaming\" | \"partial\"\n>;\n\n/** {@inheritDoc @apollo/client/react!useQuery:function(1)} */\nexport function useQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SkipToken\n): useQuery.Result<TData, TVariables, \"empty\", Record<string, never>>;\n\n/** {@inheritDoc @apollo/client/react!useQuery:function(1)} */\nexport function useQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | SkipToken\n    | (useQuery.Options<NoInfer<TData>, NoInfer<TVariables>> & {\n        returnPartialData: true;\n      })\n): useQuery.Result<\n  TData,\n  TVariables,\n  \"empty\" | \"complete\" | \"streaming\" | \"partial\",\n  Partial<TVariables>\n>;\n\n/** {@inheritDoc @apollo/client/react!useQuery:function(1)} */\nexport function useQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useQuery.Options<NoInfer<TData>, NoInfer<TVariables>> & {\n    returnPartialData: boolean;\n  }\n): useQuery.Result<\n  TData,\n  TVariables,\n  \"empty\" | \"complete\" | \"streaming\" | \"partial\"\n>;\n\n/** {@inheritDoc @apollo/client/react!useQuery:function(1)} */\nexport function useQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | SkipToken\n    | (useQuery.Options<NoInfer<TData>, NoInfer<TVariables>> & {\n        returnPartialData: boolean;\n      })\n): useQuery.Result<\n  TData,\n  TVariables,\n  \"empty\" | \"complete\" | \"streaming\" | \"partial\",\n  Partial<TVariables>\n>;\n\n/** {@inheritDoc @apollo/client/react!useQuery:function(1)} */\nexport function useQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  ...[options]: {} extends TVariables ?\n    [options?: useQuery.Options<NoInfer<TData>, NoInfer<TVariables>>]\n  : [options: useQuery.Options<NoInfer<TData>, NoInfer<TVariables>>]\n): useQuery.Result<TData, TVariables, \"empty\" | \"complete\" | \"streaming\">;\n\n/** {@inheritDoc @apollo/client/react!useQuery:function(1)} */\nexport function useQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  ...[options]: {} extends TVariables ?\n    [\n      options?:\n        | SkipToken\n        | useQuery.Options<NoInfer<TData>, NoInfer<TVariables>>,\n    ]\n  : [options: SkipToken | useQuery.Options<NoInfer<TData>, NoInfer<TVariables>>]\n): useQuery.Result<\n  TData,\n  TVariables,\n  \"empty\" | \"complete\" | \"streaming\",\n  Partial<TVariables>\n>;\n\nexport function useQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  ...[options]: {} extends TVariables ?\n    [\n      options?:\n        | SkipToken\n        | useQuery.Options<NoInfer<TData>, NoInfer<TVariables>>,\n    ]\n  : [options: SkipToken | useQuery.Options<NoInfer<TData>, NoInfer<TVariables>>]\n): useQuery.Result<TData, TVariables> {\n  \"use no memo\";\n  return wrapHook(\n    \"useQuery\",\n    // eslint-disable-next-line react-compiler/react-compiler\n    useQuery_,\n    useApolloClient(typeof options === \"object\" ? options.client : undefined)\n  )(query, options);\n}\n\nfunction useQuery_<TData, TVariables extends OperationVariables>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | SkipToken\n    | useQuery.Options<\n        NoInfer<TData>,\n        NoInfer<TVariables>\n      > = {} as useQuery.Options<TData, TVariables>\n): useQuery.Result<TData, TVariables> {\n  const client = useApolloClient(\n    typeof options === \"object\" ? options.client : undefined\n  );\n  const { ssr } = typeof options === \"object\" ? options : {};\n\n  const watchQueryOptions = useOptions(\n    query,\n    options,\n    client.defaultOptions.watchQuery\n  );\n\n  function createState(\n    previous?: InternalState<TData, TVariables>\n  ): InternalState<TData, TVariables> {\n    const observable = client.watchQuery(watchQueryOptions);\n\n    return {\n      client,\n      query,\n      observable,\n      resultData: {\n        current: observable.getCurrentResult(),\n        // Reuse previousData from previous InternalState (if any) to provide\n        // continuity of previousData even if/when the query or client changes.\n        previousData: previous?.resultData.current.data as TData,\n        variables: observable.variables,\n      },\n    };\n  }\n\n  let [state, setState] = React.useState(createState);\n\n  if (client !== state.client || query !== state.query) {\n    // If the client or query have changed, we need to create a new InternalState.\n    // This will trigger a re-render with the new state, but it will also continue\n    // to run the current render function to completion.\n    // Since we sometimes trigger some side-effects in the render function, we\n    // re-assign `state` to the new state to ensure that those side-effects are\n    // triggered with the new state.\n    setState((state = createState(state)));\n  }\n\n  const { observable, resultData } = state;\n\n  useInitialFetchPolicyIfNecessary<TData, TVariables>(\n    watchQueryOptions,\n    observable\n  );\n\n  useResubscribeIfNecessary<TData, TVariables>(\n    resultData, // might get mutated during render\n    observable, // might get mutated during render\n    watchQueryOptions\n  );\n\n  const result = useResult<TData, TVariables>(observable, resultData, ssr);\n\n  const obsQueryFields = React.useMemo(\n    () => ({\n      refetch: observable.refetch.bind(observable),\n      fetchMore: observable.fetchMore.bind(observable),\n      updateQuery: observable.updateQuery.bind(observable),\n      startPolling: observable.startPolling.bind(observable),\n      stopPolling: observable.stopPolling.bind(observable),\n      subscribeToMore: observable.subscribeToMore.bind(observable),\n    }),\n    [observable]\n  );\n\n  const previousData = resultData.previousData;\n  return React.useMemo(() => {\n    const { partial, ...rest } = result;\n\n    return {\n      ...rest,\n      client,\n      observable,\n      variables: observable.variables,\n      previousData,\n      ...obsQueryFields,\n    };\n  }, [result, client, observable, previousData, obsQueryFields]);\n}\n\nconst fromSkipToken = Symbol();\n\nfunction useOptions<TData, TVariables extends OperationVariables>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SkipToken | useQuery.Options<NoInfer<TData>, NoInfer<TVariables>>,\n  defaultOptions: Partial<ApolloClient.WatchQueryOptions<any, any>> | undefined\n): ApolloClient.WatchQueryOptions<TData, TVariables> {\n  return useDeepMemo<ApolloClient.WatchQueryOptions<TData, TVariables>>(() => {\n    if (options === skipToken) {\n      const opts: ApolloClient.WatchQueryOptions<TData, TVariables> =\n        mergeOptions(defaultOptions as any, {\n          query,\n          fetchPolicy: \"standby\",\n        });\n\n      (opts as any)[fromSkipToken] = true;\n\n      return opts;\n    }\n\n    const watchQueryOptions: ApolloClient.WatchQueryOptions<TData, TVariables> =\n      mergeOptions(defaultOptions as any, { ...options, query });\n\n    if (options.skip) {\n      watchQueryOptions.initialFetchPolicy =\n        options.initialFetchPolicy || options.fetchPolicy;\n      watchQueryOptions.fetchPolicy = \"standby\";\n    }\n\n    return watchQueryOptions;\n  }, [query, options, defaultOptions]);\n}\n\nfunction useInitialFetchPolicyIfNecessary<\n  TData,\n  TVariables extends OperationVariables,\n>(\n  watchQueryOptions: ApolloClient.WatchQueryOptions<TData, TVariables>,\n  observable: ObsQueryWithMeta<TData, TVariables>\n) {\n  \"use no memo\";\n  if (!watchQueryOptions.fetchPolicy) {\n    watchQueryOptions.fetchPolicy = observable.options.initialFetchPolicy;\n  }\n}\n\nfunction useResult<TData, TVariables extends OperationVariables>(\n  observable: ObsQueryWithMeta<TData, TVariables>,\n  resultData: InternalResult<TData>,\n  ssr: boolean | undefined\n) {\n  \"use no memo\";\n  return useSyncExternalStore(\n    React.useCallback(\n      (handleStoreChange) => {\n        const subscription = observable\n          // We use the asapScheduler here to prevent issues with trying to\n          // update in the middle of a render. `reobserve` is kicked off in the\n          // middle of a render and because RxJS emits values synchronously,\n          // its possible for this `handleStoreChange` to be called in that same\n          // render. This allows the render to complete before trying to emit a\n          // new value.\n          .pipe(observeOn(asapScheduler))\n          .subscribe((result) => {\n            const previous = resultData.current;\n\n            if (\n              // Avoid rerendering if the result is the same\n              equal(previous, result) &&\n              // Force rerender if the value was emitted because variables\n              // changed, such as when calling `refetch(newVars)` which returns\n              // the same data when `notifyOnNetworkStatusChange` is `false`.\n              equal(resultData.variables, observable.variables)\n            ) {\n              return;\n            }\n\n            // eslint-disable-next-line react-compiler/react-compiler\n            resultData.variables = observable.variables;\n\n            if (previous.data && !equal(previous.data, result.data)) {\n              resultData.previousData = previous.data as TData;\n            }\n\n            resultData.current = result;\n            handleStoreChange();\n          });\n\n        // Do the \"unsubscribe\" with a short delay.\n        // This way, an existing subscription can be reused without an additional\n        // request if \"unsubscribe\"  and \"resubscribe\" to the same ObservableQuery\n        // happen in very fast succession.\n        return () => {\n          setTimeout(() => subscription.unsubscribe());\n        };\n      },\n\n      [observable, resultData]\n    ),\n    () => resultData.current,\n    () => (ssr === false ? useQuery.ssrDisabledResult : resultData.current)\n  );\n}\n\n// this hook is not compatible with any rules of React, and there's no good way to rewrite it.\n// it should stay a separate hook that will not be optimized by the compiler\nfunction useResubscribeIfNecessary<\n  TData,\n  TVariables extends OperationVariables,\n>(\n  /** this hook will mutate properties on `resultData` */\n  resultData: InternalResult<TData>,\n  /** this hook will mutate properties on `observable` */\n  observable: ObsQueryWithMeta<TData, TVariables>,\n  watchQueryOptions: Readonly<ApolloClient.WatchQueryOptions<TData, TVariables>>\n) {\n  \"use no memo\";\n  if (\n    observable[lastWatchOptions] &&\n    !equal(observable[lastWatchOptions], watchQueryOptions)\n  ) {\n    // If skipToken was used to generate options, we won't know the correct\n    // initialFetchPolicy until the hook is rerendered with real options, so we\n    // set it the next time we get real options\n    if (\n      (observable[lastWatchOptions] as any)[fromSkipToken] &&\n      !watchQueryOptions.initialFetchPolicy\n    ) {\n      (watchQueryOptions.initialFetchPolicy as any) =\n        watchQueryOptions.fetchPolicy;\n    }\n    // Though it might be tempting to postpone this reobserve call to the\n    // useEffect block, we need getCurrentResult to return an appropriate\n    // loading:true result synchronously (later within the same call to\n    // useQuery). Since we already have this.observable here (not true for\n    // the very first call to useQuery), we are not initiating any new\n    // subscriptions, though it does feel less than ideal that reobserve\n    // (potentially) kicks off a network request (for example, when the\n    // variables have changed), which is technically a side-effect.\n    if (shouldReobserve(observable[lastWatchOptions], watchQueryOptions)) {\n      observable.reobserve(watchQueryOptions);\n    } else {\n      observable.applyOptions(watchQueryOptions);\n    }\n\n    // Make sure getCurrentResult returns a fresh ApolloQueryResult<TData>,\n    // but save the current data as this.previousData, just like setResult\n    // usually does.\n    const result = observable.getCurrentResult();\n\n    if (!equal(result.data, resultData.current.data)) {\n      resultData.previousData = (resultData.current.data ||\n        (resultData.previousData as TData)) as TData;\n    }\n    resultData.current = result;\n    resultData.variables = observable.variables;\n  }\n  observable[lastWatchOptions] = watchQueryOptions;\n}\n\nfunction shouldReobserve<TData, TVariables extends OperationVariables>(\n  previousOptions: Readonly<ApolloClient.WatchQueryOptions<TData, TVariables>>,\n  options: Readonly<ApolloClient.WatchQueryOptions<TData, TVariables>>\n) {\n  return (\n    previousOptions.query !== options.query ||\n    !equal(previousOptions.variables, options.variables) ||\n    (previousOptions.fetchPolicy !== options.fetchPolicy &&\n      (options.fetchPolicy === \"standby\" ||\n        previousOptions.fetchPolicy === \"standby\"))\n  );\n}\n\nuseQuery.ssrDisabledResult = maybeDeepFreeze({\n  loading: true,\n  data: void 0 as any,\n  dataState: \"empty\",\n  error: void 0,\n  networkStatus: NetworkStatus.loading,\n  partial: true,\n}) satisfies ObservableQuery.Result<any> as ObservableQuery.Result<any>;\n", "export const skipToken = Symbol.for(\"apollo.skipToken\");\nexport type SkipToken = typeof skipToken;\n", "import type { TypedDocumentNode } from \"@graphql-typed-document-node/core\";\nimport { equal } from \"@wry/equality\";\nimport type { DocumentNode } from \"graphql\";\nimport * as React from \"react\";\n\nimport type {\n  ApolloClient,\n  DefaultContext,\n  ErrorLike,\n  ErrorPolicy,\n  FetchPolicy,\n  OperationVariables,\n} from \"@apollo/client\";\nimport type { MaybeMasked } from \"@apollo/client/masking\";\nimport type { DocumentationTypes as UtilityDocumentationTypes } from \"@apollo/client/utilities/internal\";\nimport type {\n  NoInfer,\n  VariablesOption,\n} from \"@apollo/client/utilities/internal\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport { useDeepMemo } from \"./internal/useDeepMemo.js\";\nimport { useIsomorphicLayoutEffect } from \"./internal/useIsomorphicLayoutEffect.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\n\nexport declare namespace useSubscription {\n  import _self = useSubscription;\n  export namespace Base {\n    export interface Options<\n      TData = unknown,\n      TVariables extends OperationVariables = OperationVariables,\n    > {\n      /** {@inheritDoc @apollo/client!SubscriptionOptionsDocumentation#fetchPolicy:member} */\n      fetchPolicy?: FetchPolicy;\n\n      /** {@inheritDoc @apollo/client!SubscriptionOptionsDocumentation#errorPolicy:member} */\n      errorPolicy?: ErrorPolicy;\n\n      /** {@inheritDoc @apollo/client!SubscriptionOptionsDocumentation#shouldResubscribe:member} */\n      shouldResubscribe?:\n        | boolean\n        | ((options: Options<TData, TVariables>) => boolean);\n\n      /** {@inheritDoc @apollo/client!SubscriptionOptionsDocumentation#client:member} */\n      client?: ApolloClient;\n\n      /** {@inheritDoc @apollo/client!SubscriptionOptionsDocumentation#skip:member} */\n      skip?: boolean;\n\n      /** {@inheritDoc @apollo/client!SubscriptionOptionsDocumentation#context:member} */\n      context?: DefaultContext;\n\n      /** {@inheritDoc @apollo/client!SubscriptionOptionsDocumentation#extensions:member} */\n      extensions?: Record<string, any>;\n\n      /** {@inheritDoc @apollo/client!SubscriptionOptionsDocumentation#onComplete:member} */\n      onComplete?: () => void;\n\n      /** {@inheritDoc @apollo/client!SubscriptionOptionsDocumentation#onData:member} */\n      onData?: (options: OnDataOptions<TData>) => any;\n\n      /** {@inheritDoc @apollo/client!SubscriptionOptionsDocumentation#onError:member} */\n      onError?: (error: ErrorLike) => void;\n\n      /**\n       * {@inheritDoc @apollo/client!SubscriptionOptionsDocumentation#ignoreResults:member}\n       * @defaultValue `false`\n       */\n      ignoreResults?: boolean;\n    }\n  }\n\n  export type Options<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > = Base.Options<TData, TVariables> & VariablesOption<TVariables>;\n\n  export namespace DocumentationTypes {\n    namespace useSubscription {\n      export interface Options<\n        TData = unknown,\n        TVariables extends OperationVariables = OperationVariables,\n      > extends Base.Options<TData, TVariables>,\n          UtilityDocumentationTypes.VariableOptions<TVariables> {}\n    }\n  }\n\n  export interface Result<TData = unknown> {\n    /** {@inheritDoc @apollo/client!SubscriptionResultDocumentation#loading:member} */\n    loading: boolean;\n\n    /** {@inheritDoc @apollo/client!SubscriptionResultDocumentation#data:member} */\n    data?: MaybeMasked<TData>;\n\n    /** {@inheritDoc @apollo/client!SubscriptionResultDocumentation#error:member} */\n    error?: ErrorLike;\n\n    /**\n     * A function that when called will disconnect and reconnect the connection\n     * to the subscription. If the subscription is deduplicated, this will\n     * restart the connection for all deduplicated subscriptions.\n     */\n    restart: () => void;\n  }\n\n  export namespace DocumentationTypes {\n    namespace useSubscription {\n      export interface Result<TData = unknown> extends _self.Result<TData> {}\n    }\n  }\n\n  export namespace DocumentationTypes {\n    /** {@inheritDoc @apollo/client/react!useSubscription:function(1)} */\n    export function useSubscription<\n      TData = unknown,\n      TVariables extends OperationVariables = OperationVariables,\n    >(\n      options?: useSubscription.Options<TData, TVariables>\n    ): useSubscription.Result<TData>;\n  }\n\n  export type OnDataResult<TData = unknown> = Omit<Result<TData>, \"restart\">;\n\n  export interface OnDataOptions<TData = unknown> {\n    client: ApolloClient;\n    data: OnDataResult<TData>;\n  }\n\n  export interface OnSubscriptionDataOptions<TData = unknown> {\n    client: ApolloClient;\n    subscriptionData: OnDataResult<TData>;\n  }\n}\n\n/**\n * > Refer to the [Subscriptions](https://www.apollographql.com/docs/react/data/subscriptions/) section for a more in-depth overview of `useSubscription`.\n *\n * @example\n *\n * ```jsx\n * const COMMENTS_SUBSCRIPTION = gql`\n *   subscription OnCommentAdded($repoFullName: String!) {\n *     commentAdded(repoFullName: $repoFullName) {\n *       id\n *       content\n *     }\n *   }\n * `;\n *\n * function DontReadTheComments({ repoFullName }) {\n *   const {\n *     data: { commentAdded },\n *     loading,\n *   } = useSubscription(COMMENTS_SUBSCRIPTION, { variables: { repoFullName } });\n *   return <h4>New comment: {!loading && commentAdded.content}</h4>;\n * }\n * ```\n *\n * @remarks\n *\n * #### Consider using `onData` instead of `useEffect`\n *\n * If you want to react to incoming data, please use the `onData` option instead of `useEffect`.\n * State updates you make inside a `useEffect` hook might cause additional rerenders, and `useEffect` is mostly meant for side effects of rendering, not as an event handler.\n * State updates made in an event handler like `onData` might - depending on the React version - be batched and cause only a single rerender.\n *\n * Consider the following component:\n *\n * ```jsx\n * export function Subscriptions() {\n *   const { data, error, loading } = useSubscription(query);\n *   const [accumulatedData, setAccumulatedData] = useState([]);\n *\n *   useEffect(() => {\n *     setAccumulatedData((prev) => [...prev, data]);\n *   }, [data]);\n *\n *   return (\n *     <>\n *       {loading && <p>Loading...</p>}\n *       {JSON.stringify(accumulatedData, undefined, 2)}\n *     </>\n *   );\n * }\n * ```\n *\n * Instead of using `useEffect` here, we can re-write this component to use the `onData` callback function accepted in `useSubscription`'s `options` object:\n *\n * ```jsx\n * export function Subscriptions() {\n *   const [accumulatedData, setAccumulatedData] = useState([]);\n *   const { data, error, loading } = useSubscription(query, {\n *     onData({ data }) {\n *       setAccumulatedData((prev) => [...prev, data]);\n *     },\n *   });\n *\n *   return (\n *     <>\n *       {loading && <p>Loading...</p>}\n *       {JSON.stringify(accumulatedData, undefined, 2)}\n *     </>\n *   );\n * }\n * ```\n *\n * >  **Note:** The `useSubscription` option `onData` is available in Apollo Client >= 3.7. In previous versions, the equivalent option is named `onSubscriptionData`.\n *\n * Now, the first message will be added to the `accumulatedData` array since `onData` is called _before_ the component re-renders. React 18 automatic batching is still in effect and results in a single re-render, but with `onData` we can guarantee each message received after the component mounts is added to `accumulatedData`.\n *\n * @param subscription - A GraphQL subscription document parsed into an AST by `gql`.\n * @param options - Options to control how the subscription is executed.\n * @returns Query result object\n */\nexport function useSubscription<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  subscription: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  ...[options = {} as useSubscription.Options<TData, TVariables>]: {} extends (\n    TVariables\n  ) ?\n    [options?: useSubscription.Options<NoInfer<TData>, NoInfer<TVariables>>]\n  : [options: useSubscription.Options<NoInfer<TData>, NoInfer<TVariables>>]\n): useSubscription.Result<TData> {\n  const client = useApolloClient(options.client);\n\n  const {\n    skip,\n    fetchPolicy,\n    errorPolicy,\n    shouldResubscribe,\n    context,\n    extensions,\n    ignoreResults,\n  } = options;\n  const variables = useDeepMemo(() => options.variables, [options.variables]);\n\n  const recreate = () =>\n    createSubscription(\n      client,\n      subscription,\n      variables,\n      fetchPolicy,\n      errorPolicy,\n      context,\n      extensions\n    );\n\n  let [observable, setObservable] = React.useState(\n    options.skip ? null : recreate\n  );\n\n  const recreateRef = React.useRef(recreate);\n  useIsomorphicLayoutEffect(() => {\n    recreateRef.current = recreate;\n  });\n\n  if (skip) {\n    if (observable) {\n      setObservable((observable = null));\n    }\n  } else if (\n    !observable ||\n    ((client !== observable.__.client ||\n      subscription !== observable.__.query ||\n      fetchPolicy !== observable.__.fetchPolicy ||\n      errorPolicy !== observable.__.errorPolicy ||\n      !equal(variables, observable.__.variables)) &&\n      (typeof shouldResubscribe === \"function\" ?\n        !!shouldResubscribe(options!)\n      : shouldResubscribe) !== false)\n  ) {\n    setObservable((observable = recreate()));\n  }\n\n  const optionsRef = React.useRef(options);\n  React.useEffect(() => {\n    optionsRef.current = options;\n  });\n\n  const fallbackLoading = !skip && !ignoreResults;\n  const fallbackResult = React.useMemo(\n    () => ({\n      loading: fallbackLoading,\n      error: void 0,\n      data: void 0,\n    }),\n    [fallbackLoading]\n  );\n\n  const ignoreResultsRef = React.useRef(ignoreResults);\n  useIsomorphicLayoutEffect(() => {\n    // We cannot reference `ignoreResults` directly in the effect below\n    // it would add a dependency to the `useEffect` deps array, which means the\n    // subscription would be recreated if `ignoreResults` changes\n    // As a result, on resubscription, the last result would be re-delivered,\n    // rendering the component one additional time, and re-triggering `onData`.\n    // The same applies to `fetchPolicy`, which results in a new `observable`\n    // being created. We cannot really avoid it in that case, but we can at least\n    // avoid it for `ignoreResults`.\n    ignoreResultsRef.current = ignoreResults;\n  });\n\n  const ret = useSyncExternalStore(\n    React.useCallback(\n      (update) => {\n        if (!observable) {\n          return () => {};\n        }\n\n        let subscriptionStopped = false;\n        const client = observable.__.client;\n        const subscription = observable.subscribe({\n          next(value) {\n            if (subscriptionStopped) {\n              return;\n            }\n\n            const result = {\n              loading: false,\n              data: value.data,\n              error: value.error,\n            };\n\n            observable.__.setResult(result);\n            if (!ignoreResultsRef.current) update();\n\n            if (result.error) {\n              optionsRef.current.onError?.(result.error);\n            } else if (optionsRef.current.onData) {\n              optionsRef.current.onData({\n                client,\n                data: result,\n              });\n            }\n          },\n          complete() {\n            observable.__.completed = true;\n            if (!subscriptionStopped && optionsRef.current.onComplete) {\n              optionsRef.current.onComplete();\n            }\n          },\n        });\n\n        return () => {\n          // immediately stop receiving subscription values, but do not unsubscribe\n          // until after a short delay in case another useSubscription hook is\n          // reusing the same underlying observable and is about to subscribe\n          subscriptionStopped = true;\n\n          setTimeout(() => subscription.unsubscribe());\n        };\n      },\n      [observable]\n    ),\n    () =>\n      observable && !skip && !ignoreResults ?\n        observable.__.result\n      : fallbackResult,\n    () => fallbackResult\n  );\n\n  const restart = React.useCallback(() => {\n    invariant(\n      !optionsRef.current.skip,\n      \"A subscription that is skipped cannot be restarted.\"\n    );\n    if (observable?.__.completed) {\n      setObservable(recreateRef.current());\n    } else {\n      observable?.restart();\n    }\n  }, [optionsRef, recreateRef, observable]);\n\n  return React.useMemo(() => ({ ...ret, restart }), [ret, restart]);\n}\n\ntype SubscriptionResult<TData> = Omit<useSubscription.Result<TData>, \"restart\">;\n\nfunction createSubscription<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  client: ApolloClient,\n  query: TypedDocumentNode<TData, TVariables>,\n  variables: TVariables | undefined,\n  fetchPolicy: FetchPolicy | undefined,\n  errorPolicy: ErrorPolicy | undefined,\n  context: DefaultContext | undefined,\n  extensions: Record<string, any> | undefined\n) {\n  const options = {\n    query,\n    variables,\n    fetchPolicy,\n    errorPolicy,\n    context,\n    extensions,\n  } as ApolloClient.SubscribeOptions<TData, TVariables>;\n  const __ = {\n    ...options,\n    client,\n    completed: false,\n    result: {\n      loading: true,\n      data: void 0,\n      error: void 0,\n    } as SubscriptionResult<TData>,\n    setResult(result: SubscriptionResult<TData>) {\n      __.result = result;\n    },\n  };\n\n  return Object.assign(client.subscribe(options), {\n    /**\n     * A tracking object to store details about the observable and the latest result of the subscription.\n     */\n    __,\n  });\n}\n", "import * as React from \"react\";\n\nimport type { ReactiveVar } from \"@apollo/client\";\n\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\n\n/**\n * Reads the value of a [reactive variable](https://www.apollographql.com/docs/react/local-state/reactive-variables/) and re-renders the containing component whenever that variable's value changes. This enables a reactive variable to trigger changes _without_ relying on the `useQuery` hook.\n *\n * @example\n *\n * ```jsx\n * import { makeVar, useReactiveVar } from \"@apollo/client\";\n * export const cartItemsVar = makeVar([]);\n *\n * export function Cart() {\n *   const cartItems = useReactiveVar(cartItemsVar);\n *   // ...\n * }\n * ```\n *\n * @param rv - A reactive variable.\n * @returns The current value of the reactive variable.\n */\nexport function useReactiveVar<T>(rv: ReactiveVar<T>): T {\n  return useSyncExternalStore(\n    React.useCallback(\n      (update) => {\n        // By reusing the same onNext function in the nested call to\n        // rv.onNextChange(onNext), we can keep using the initial clean-up function\n        // returned by rv.onNextChange(function onNext(v){...}), without having to\n        // register the new clean-up function (returned by the nested\n        // rv.onNextChange(onNext)) with yet another callback.\n        return rv.onNextChange(function onNext() {\n          update();\n          rv.onNextChange(onNext);\n        });\n      },\n      [rv]\n    ),\n    rv,\n    rv\n  );\n}\n", "import { equal } from \"@wry/equality\";\nimport * as React from \"react\";\n\nimport type {\n  ApolloClient,\n  DataValue,\n  DocumentNode,\n  GetDataState,\n  OperationVariables,\n  TypedDocumentNode,\n} from \"@apollo/client\";\nimport type {\n  Cache,\n  MissingTree,\n  Reference,\n  StoreObject,\n} from \"@apollo/client/cache\";\nimport type { FragmentType, MaybeMasked } from \"@apollo/client/masking\";\nimport type { NoInfer } from \"@apollo/client/utilities/internal\";\n\nimport { useDeepMemo, wrapHook } from \"./internal/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\n\nexport declare namespace useFragment {\n  import _self = useFragment;\n  export interface Options<TData, TVariables extends OperationVariables> {\n    /**\n     * A GraphQL document created using the `gql` template string tag from\n     * `graphql-tag` with one or more fragments which will be used to determine\n     * the shape of data to read. If you provide more than one fragment in this\n     * document then you must also specify `fragmentName` to select a single.\n     */\n    fragment: DocumentNode | TypedDocumentNode<TData, TVariables>;\n\n    /**\n     * The name of the fragment in your GraphQL document to be used. If you do\n     * not provide a `fragmentName` and there is only one fragment in your\n     * `fragment` document then that fragment will be used.\n     */\n    fragmentName?: string;\n\n    /**\n     * Any variables that the GraphQL query may depend on.\n     */\n    variables?: NoInfer<TVariables>;\n\n    /**\n     * An object containing a `__typename` and primary key fields (such as `id`) identifying the entity object from which the fragment will be retrieved, or a `{ __ref: \"...\" }` reference, or a `string` ID (uncommon).\n     */\n    from:\n      | StoreObject\n      | Reference\n      | FragmentType<NoInfer<TData>>\n      | string\n      | null;\n\n    /**\n     * Whether to read from optimistic or non-optimistic cache data. If\n     * this named option is provided, the optimistic parameter of the\n     * readQuery method can be omitted.\n     *\n     * @defaultValue true\n     */\n    optimistic?: boolean;\n\n    /**\n     * The instance of `ApolloClient` to use to look up the fragment.\n     *\n     * By default, the instance that's passed down via context is used, but you\n     * can provide a different instance here.\n     *\n     * @docGroup 1. Operation options\n     */\n    client?: ApolloClient;\n  }\n\n  namespace DocumentationTypes {\n    namespace useFragment {\n      export interface Options<\n        TData = unknown,\n        TVariables extends OperationVariables = OperationVariables,\n      > extends _self.Options<TData, TVariables> {}\n    }\n  }\n\n  // TODO: Update this to return `null` when there is no data returned from the\n  // fragment.\n  export type Result<TData> =\n    | ({\n        /** {@inheritDoc @apollo/client/react!useFragment.DocumentationTypes.useFragment.Result#complete:member} */\n        complete: true;\n        /** {@inheritDoc @apollo/client/react!useFragment.DocumentationTypes.useFragment.Result#missing:member} */\n        missing?: never;\n      } & GetDataState<MaybeMasked<TData>, \"complete\">)\n    | ({\n        /** {@inheritDoc @apollo/client/react!useFragment.DocumentationTypes.useFragment.Result#complete:member} */\n        complete: false;\n        /** {@inheritDoc @apollo/client/react!useFragment.DocumentationTypes.useFragment.Result#missing:member} */\n        missing?: MissingTree;\n      } & GetDataState<MaybeMasked<TData>, \"partial\">);\n\n  export namespace DocumentationTypes {\n    namespace useFragment {\n      export interface Result<TData> {\n        data: MaybeMasked<TData> | DataValue.Partial<MaybeMasked<TData>>;\n        complete: boolean;\n        /**\n         * A tree of all `MissingFieldError` messages reported during fragment reading, where the branches of the tree indicate the paths of the errors within the query result.\n         */\n        missing?: MissingTree;\n      }\n    }\n  }\n  export namespace DocumentationTypes {\n    /** {@inheritDoc @apollo/client/react!useFragment:function(1)} */\n    export function useFragment<\n      TData = unknown,\n      TVariables extends OperationVariables = OperationVariables,\n    >({\n      fragment,\n      from,\n      fragmentName,\n      variables,\n      optimistic,\n      client,\n    }: useFragment.Options<TData, TVariables>): useFragment.Result<TData>;\n  }\n}\n\n/**\n * `useFragment` represents a lightweight live binding into the Apollo Client Cache and enables Apollo Client to broadcast very specific fragment results to individual components. This hook returns an always-up-to-date view of whatever data the cache currently contains for a given fragment. `useFragment` never triggers network requests of its own.\n *\n * Note that the `useQuery` hook remains the primary hook responsible for querying and populating data in the cache ([see the API reference](./hooks#usequery)). As a result, the component reading the fragment data via `useFragment` is still subscribed to all changes in the query data, but receives updates only when that fragment's specific data change.\n *\n * To view a `useFragment` example, see the [Fragments](https://www.apollographql.com/docs/react/data/fragments#usefragment) page.\n */\nexport function useFragment<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(options: useFragment.Options<TData, TVariables>): useFragment.Result<TData> {\n  \"use no memo\";\n  return wrapHook(\n    \"useFragment\",\n    // eslint-disable-next-line react-compiler/react-compiler\n    useFragment_,\n    useApolloClient(options.client)\n  )(options);\n}\n\nfunction useFragment_<TData, TVariables extends OperationVariables>(\n  options: useFragment.Options<TData, TVariables>\n): useFragment.Result<TData> {\n  const client = useApolloClient(options.client);\n  const { cache } = client;\n  const { from, ...rest } = options;\n\n  // We calculate the cache id seperately from `stableOptions` because we don't\n  // want changes to non key fields in the `from` property to affect\n  // `stableOptions` and retrigger our subscription. If the cache identifier\n  // stays the same between renders, we want to reuse the existing subscription.\n  const id = React.useMemo(\n    () =>\n      typeof from === \"string\" ? from\n      : from === null ? null\n      : cache.identify(from),\n    [cache, from]\n  );\n\n  const stableOptions = useDeepMemo(() => ({ ...rest, from: id! }), [rest, id]);\n\n  // Since .next is async, we need to make sure that we\n  // get the correct diff on the next render given new diffOptions\n  const diff = React.useMemo(() => {\n    const { fragment, fragmentName, from, optimistic = true } = stableOptions;\n\n    if (from === null) {\n      return {\n        result: diffToResult({\n          result: {},\n          complete: false,\n        } as Cache.DiffResult<TData>),\n      };\n    }\n\n    const { cache } = client;\n    const diff = cache.diff<TData, TVariables>({\n      ...stableOptions,\n      returnPartialData: true,\n      id: from,\n      query: cache[\"getFragmentDoc\"](\n        client[\"transform\"](fragment),\n        fragmentName\n      ),\n      optimistic,\n    });\n\n    return {\n      result: diffToResult<TData>({\n        ...diff,\n        result: client[\"queryManager\"].maskFragment({\n          fragment,\n          fragmentName,\n          // TODO: Revert to `diff.result` once `useFragment` supports `null` as\n          // valid return value\n          data: diff.result === null ? {} : diff.result,\n        }) as any,\n      }),\n    };\n  }, [client, stableOptions]);\n\n  // Used for both getSnapshot and getServerSnapshot\n  const getSnapshot = React.useCallback(() => diff.result, [diff]);\n\n  return useSyncExternalStore(\n    React.useCallback(\n      (forceUpdate) => {\n        let lastTimeout = 0;\n\n        const subscription =\n          stableOptions.from === null ?\n            null\n          : client.watchFragment(stableOptions).subscribe({\n              next: (result) => {\n                // Avoid unnecessarily rerendering this hook for the initial result\n                // emitted from watchFragment which should be equal to\n                // `diff.result`.\n                if (equal(result, diff.result)) return;\n                diff.result = result;\n                // If we get another update before we've re-rendered, bail out of\n                // the update and try again. This ensures that the relative timing\n                // between useQuery and useFragment stays roughly the same as\n                // fixed in https://github.com/apollographql/apollo-client/pull/11083\n                clearTimeout(lastTimeout);\n                lastTimeout = setTimeout(forceUpdate) as any;\n              },\n            });\n        return () => {\n          subscription?.unsubscribe();\n          clearTimeout(lastTimeout);\n        };\n      },\n      [client, stableOptions, diff]\n    ),\n    getSnapshot,\n    getSnapshot\n  );\n}\n\nfunction diffToResult<TData>(\n  diff: Cache.DiffResult<TData>\n): useFragment.Result<TData> {\n  const result = {\n    data: diff.result,\n    complete: !!diff.complete,\n    dataState: diff.complete ? \"complete\" : \"partial\",\n  } as useFragment.Result<TData>; // TODO: Remove assertion once useFragment returns null\n\n  if (diff.missing) {\n    result.missing = diff.missing.missing;\n  }\n\n  return result;\n}\n", "import * as React from \"react\";\n\nimport type {\n  ApolloClient,\n  DataState,\n  DefaultContext,\n  DocumentNode,\n  ErrorLike,\n  ErrorPolicy,\n  GetDataState,\n  MaybeMasked,\n  ObservableQuery,\n  OperationVariables,\n  RefetchWritePolicy,\n  TypedDocumentNode,\n  WatchQueryFetchPolicy,\n} from \"@apollo/client\";\nimport type { SubscribeToMoreFunction } from \"@apollo/client\";\nimport { NetworkStatus } from \"@apollo/client\";\nimport { canonicalStringify } from \"@apollo/client/cache\";\nimport type {\n  CacheKey,\n  FetchMoreFunction,\n  QueryKey,\n  RefetchFunction,\n} from \"@apollo/client/react/internal\";\nimport { getSuspenseCache } from \"@apollo/client/react/internal\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport type {\n  DocumentationTypes as UtilityDocumentationTypes,\n  NoInfer,\n  VariablesOption,\n} from \"@apollo/client/utilities/internal\";\n\nimport type { SkipToken } from \"./constants.js\";\nimport { skipToken } from \"./constants.js\";\nimport { __use, useDeepMemo, wrapHook } from \"./internal/index.js\";\nimport { validateSuspenseHookOptions } from \"./internal/validateSuspenseHookOptions.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\n\nexport declare namespace useSuspenseQuery {\n  export type FetchPolicy = Extract<\n    WatchQueryFetchPolicy,\n    \"cache-first\" | \"network-only\" | \"no-cache\" | \"cache-and-network\"\n  >;\n\n  export namespace Base {\n    export interface Options<\n      TVariables extends OperationVariables = OperationVariables,\n    > {\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#client:member} */\n      client?: ApolloClient;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#context:member} */\n      context?: DefaultContext;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#errorPolicy:member} */\n      errorPolicy?: ErrorPolicy;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#returnPartialData:member} */\n      returnPartialData?: boolean;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#refetchWritePolicy_suspense:member} */\n      refetchWritePolicy?: RefetchWritePolicy;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#fetchPolicy:member} */\n      fetchPolicy?: FetchPolicy;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#queryKey:member} */\n      queryKey?: string | number | any[];\n\n      /**\n       * {@inheritDoc @apollo/client!QueryOptionsDocumentation#skip_deprecated:member}\n       *\n       * @example Recommended usage of `skipToken`:\n       *\n       * ```ts\n       * import { skipToken, useSuspenseQuery } from \"@apollo/client\";\n       *\n       * const { data } = useSuspenseQuery(\n       *   query,\n       *   id ? { variables: { id } } : skipToken\n       * );\n       * ```\n       */\n      skip?: boolean;\n    }\n  }\n  export type Options<\n    TVariables extends OperationVariables = OperationVariables,\n  > = Base.Options<TVariables> & VariablesOption<TVariables>;\n\n  export namespace DocumentationTypes {\n    namespace useSuspenseQuery {\n      export interface Options<\n        TVariables extends OperationVariables = OperationVariables,\n      > extends Base.Options<TVariables>,\n          UtilityDocumentationTypes.VariableOptions<TVariables> {}\n    }\n  }\n\n  export namespace Base {\n    export interface Result<\n      TData = unknown,\n      TVariables extends OperationVariables = OperationVariables,\n    > {\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#client:member} */\n      client: ApolloClient;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#error:member} */\n      error: ErrorLike | undefined;\n\n      /**\n       * {@inheritDoc @apollo/client!QueryResultDocumentation#fetchMore:member}\n       *\n       * @remarks\n       * Calling this function will cause the component to re-suspend, unless the call site is wrapped in [`startTransition`](https://react.dev/reference/react/startTransition).\n       */\n      fetchMore: FetchMoreFunction<TData, TVariables>;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#networkStatus:member} */\n      networkStatus: NetworkStatus;\n\n      /**\n       * {@inheritDoc @apollo/client!QueryResultDocumentation#refetch:member}\n       *\n       * @remarks\n       * Calling this function will cause the component to re-suspend, unless the call site is wrapped in [`startTransition`](https://react.dev/reference/react/startTransition).\n       */\n      refetch: RefetchFunction<TData, TVariables>;\n\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#subscribeToMore:member} */\n      subscribeToMore: SubscribeToMoreFunction<TData, TVariables>;\n    }\n  }\n  export type Result<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n    TStates extends\n      DataState<TData>[\"dataState\"] = DataState<TData>[\"dataState\"],\n  > = Base.Result<TData, TVariables> &\n    GetDataState<MaybeMasked<TData>, TStates>;\n\n  export namespace DocumentationTypes {\n    namespace useSuspenseQuery {\n      export interface Result<\n        TData = unknown,\n        TVariables extends OperationVariables = OperationVariables,\n      > extends Base.Result<TData, TVariables>,\n          UtilityDocumentationTypes.DataState<TData> {}\n    }\n  }\n  export namespace DocumentationTypes {\n    /** Test {@inheritDoc @apollo/client/react!useSuspenseQuery:function(1)} */\n    export function useSuspenseQuery<\n      TData = unknown,\n      TVariables extends OperationVariables = OperationVariables,\n    >(\n      query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n      options?: useSuspenseQuery.Options<TVariables>\n    ): useSuspenseQuery.Result<TData, TVariables>;\n  }\n}\n\n/**\n * For a detailed explanation of `useSuspenseQuery`, see the [fetching with Suspense reference](https://www.apollographql.com/docs/react/data/suspense).\n *\n * @example\n *\n * ```jsx\n * import { Suspense } from \"react\";\n * import { useSuspenseQuery } from \"@apollo/client\";\n *\n * const listQuery = gql`\n *   query {\n *     list {\n *       id\n *     }\n *   }\n * `;\n *\n * function App() {\n *   return (\n *     <Suspense fallback={<Spinner />}>\n *       <List />\n *     </Suspense>\n *   );\n * }\n *\n * function List() {\n *   const { data } = useSuspenseQuery(listQuery);\n *\n *   return (\n *     <ol>\n *       {data.list.map((item) => (\n *         <Item key={item.id} id={item.id} />\n *       ))}\n *     </ol>\n *   );\n * }\n * ```\n *\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - An optional object containing options for the query. Instead of passing a `useSuspenseQuery.Options` object into the hook, you can also pass a [`skipToken`](#skiptoken) to prevent the `useSuspenseQuery` hook from executing the query or suspending.\n */\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useSuspenseQuery.Options<NoInfer<TVariables>> & {\n    returnPartialData: true;\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): useSuspenseQuery.Result<\n  TData,\n  TVariables,\n  \"complete\" | \"streaming\" | \"partial\" | \"empty\"\n>;\n\n/** {@inheritDoc @apollo/client/react!useSuspenseQuery:function(1)} */\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useSuspenseQuery.Options<NoInfer<TVariables>> & {\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): useSuspenseQuery.Result<\n  TData,\n  TVariables,\n  \"complete\" | \"streaming\" | \"empty\"\n>;\n\n/** {@inheritDoc @apollo/client/react!useSuspenseQuery:function(1)} */\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useSuspenseQuery.Options<NoInfer<TVariables>> & {\n    skip: boolean;\n    returnPartialData: true;\n  }\n): useSuspenseQuery.Result<\n  TData,\n  TVariables,\n  \"complete\" | \"empty\" | \"streaming\" | \"partial\"\n>;\n\n/** {@inheritDoc @apollo/client/react!useSuspenseQuery:function(1)} */\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useSuspenseQuery.Options<NoInfer<TVariables>> & {\n    returnPartialData: true;\n  }\n): useSuspenseQuery.Result<\n  TData,\n  TVariables,\n  \"partial\" | \"streaming\" | \"complete\"\n>;\n\n/** {@inheritDoc @apollo/client/react!useSuspenseQuery:function(1)} */\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useSuspenseQuery.Options<NoInfer<TVariables>> & {\n    skip: boolean;\n  }\n): useSuspenseQuery.Result<\n  TData,\n  TVariables,\n  \"complete\" | \"streaming\" | \"empty\"\n>;\n\n/** {@inheritDoc @apollo/client/react!useSuspenseQuery:function(1)} */\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | SkipToken\n    | (useSuspenseQuery.Options<NoInfer<TVariables>> & {\n        returnPartialData: true;\n      })\n): useSuspenseQuery.Result<\n  TData,\n  TVariables,\n  \"empty\" | \"streaming\" | \"complete\" | \"partial\"\n>;\n\n/** {@inheritDoc @apollo/client/react!useSuspenseQuery:function(1)} */\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  ...[options]: {} extends TVariables ?\n    [options?: useSuspenseQuery.Options<NoInfer<TVariables>>]\n  : [options: useSuspenseQuery.Options<NoInfer<TVariables>>]\n): useSuspenseQuery.Result<TData, TVariables, \"complete\" | \"streaming\">;\n\n/** {@inheritDoc @apollo/client/react!useSuspenseQuery:function(1)} */\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  ...[options]: {} extends TVariables ?\n    [options?: SkipToken | useSuspenseQuery.Options<NoInfer<TVariables>>]\n  : [options: SkipToken | useSuspenseQuery.Options<NoInfer<TVariables>>]\n): useSuspenseQuery.Result<\n  TData,\n  TVariables,\n  \"complete\" | \"streaming\" | \"empty\"\n>;\n\n/** {@inheritDoc @apollo/client/react!useSuspenseQuery:function(1)} */\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SkipToken | useSuspenseQuery.Options<NoInfer<TVariables>>\n): useSuspenseQuery.Result<\n  TData,\n  TVariables,\n  \"complete\" | \"streaming\" | \"empty\"\n>;\n\nexport function useSuspenseQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: SkipToken | useSuspenseQuery.Options<NoInfer<TVariables>>\n): useSuspenseQuery.Result<\n  TData,\n  TVariables,\n  \"empty\" | \"streaming\" | \"complete\" | \"partial\"\n> {\n  \"use no memo\";\n  return wrapHook(\n    \"useSuspenseQuery\",\n    // eslint-disable-next-line react-compiler/react-compiler\n    useSuspenseQuery_,\n    useApolloClient(typeof options === \"object\" ? options.client : undefined)\n  )(query, options ?? ({} as any));\n}\n\nfunction useSuspenseQuery_<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | (SkipToken & Partial<useSuspenseQuery.Options<TVariables>>)\n    | useSuspenseQuery.Options<TVariables>\n): useSuspenseQuery.Result<\n  TData,\n  TVariables,\n  \"partial\" | \"complete\" | \"streaming\" | \"empty\"\n> {\n  const client = useApolloClient(options.client);\n  const suspenseCache = getSuspenseCache(client);\n  const watchQueryOptions = useWatchQueryOptions<any, any>({\n    client,\n    query,\n    options,\n  });\n  const { fetchPolicy, variables } = watchQueryOptions;\n  const { queryKey = [] } = options;\n\n  const cacheKey: CacheKey = [\n    query,\n    canonicalStringify(variables),\n    ...([] as any[]).concat(queryKey),\n  ];\n\n  const queryRef = suspenseCache.getQueryRef(cacheKey, () =>\n    client.watchQuery(watchQueryOptions)\n  );\n\n  let [current, setPromise] = React.useState<\n    [QueryKey, Promise<ObservableQuery.Result<any>>]\n  >([queryRef.key, queryRef.promise]);\n\n  // This saves us a re-execution of the render function when a variable changed.\n  if (current[0] !== queryRef.key) {\n    // eslint-disable-next-line react-compiler/react-compiler\n    current[0] = queryRef.key;\n    current[1] = queryRef.promise;\n  }\n  let promise = current[1];\n\n  if (queryRef.didChangeOptions(watchQueryOptions)) {\n    current[1] = promise = queryRef.applyOptions(watchQueryOptions);\n  }\n\n  React.useEffect(() => {\n    const dispose = queryRef.retain();\n\n    const removeListener = queryRef.listen((promise) => {\n      setPromise([queryRef.key, promise]);\n    });\n\n    return () => {\n      removeListener();\n      dispose();\n    };\n  }, [queryRef]);\n\n  const skipResult = React.useMemo<ObservableQuery.Result<TData>>(() => {\n    const error = queryRef.result.error;\n    const complete = !!queryRef.result.data;\n\n    return {\n      loading: false,\n      data: queryRef.result.data,\n      dataState: queryRef.result.dataState,\n      networkStatus: error ? NetworkStatus.error : NetworkStatus.ready,\n      error,\n      complete,\n      partial: !complete,\n    };\n  }, [queryRef.result]);\n\n  const result = fetchPolicy === \"standby\" ? skipResult : __use(promise);\n\n  const fetchMore = React.useCallback<\n    FetchMoreFunction<unknown, OperationVariables>\n  >(\n    (options) => {\n      const promise = queryRef.fetchMore(options);\n      setPromise([queryRef.key, queryRef.promise]);\n\n      return promise;\n    },\n    [queryRef]\n  ) as FetchMoreFunction<TData | undefined, TVariables>;\n\n  const refetch: RefetchFunction<TData, TVariables> = React.useCallback(\n    (variables) => {\n      const promise = queryRef.refetch(variables);\n      setPromise([queryRef.key, queryRef.promise]);\n\n      return promise;\n    },\n    [queryRef]\n  );\n\n  // TODO: The internalQueryRef doesn't have TVariables' type information so we have to cast it here\n  const subscribeToMore = queryRef.observable\n    .subscribeToMore as SubscribeToMoreFunction<TData | undefined, TVariables>;\n\n  return React.useMemo<\n    useSuspenseQuery.Result<TData, TVariables, DataState<TData>[\"dataState\"]>\n  >(() => {\n    return {\n      client,\n      data: result.data,\n      dataState: result.dataState,\n      error: result.error,\n      networkStatus: result.networkStatus,\n      fetchMore,\n      refetch,\n      subscribeToMore,\n    } as useSuspenseQuery.Result<\n      TData,\n      TVariables,\n      DataState<TData>[\"dataState\"]\n    >;\n  }, [client, fetchMore, refetch, result, subscribeToMore]);\n}\n\ninterface UseWatchQueryOptionsHookOptions<\n  TData,\n  TVariables extends OperationVariables,\n> {\n  client: ApolloClient;\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n  options: SkipToken | useSuspenseQuery.Options<TVariables>;\n}\n\nexport function useWatchQueryOptions<\n  TData,\n  TVariables extends OperationVariables,\n>({\n  client,\n  query,\n  options,\n}: UseWatchQueryOptionsHookOptions<\n  TData,\n  TVariables\n>): ApolloClient.WatchQueryOptions<TData, TVariables> {\n  return useDeepMemo<ApolloClient.WatchQueryOptions<TData, TVariables>>(() => {\n    if (options === skipToken) {\n      return {\n        query,\n        fetchPolicy: \"standby\",\n      } as ApolloClient.WatchQueryOptions<TData, TVariables>;\n    }\n\n    const fetchPolicy =\n      options.fetchPolicy ||\n      client.defaultOptions.watchQuery?.fetchPolicy ||\n      \"cache-first\";\n\n    const watchQueryOptions: ApolloClient.WatchQueryOptions<TData, TVariables> =\n      {\n        ...options,\n        fetchPolicy,\n        query,\n        notifyOnNetworkStatusChange: false,\n        nextFetchPolicy: void 0,\n      };\n\n    if (__DEV__) {\n      validateSuspenseHookOptions(watchQueryOptions);\n    }\n\n    // Assign the updated fetch policy after our validation since `standby` is\n    // not a supported fetch policy on its own without the use of `skip`.\n    if (options.skip) {\n      watchQueryOptions.fetchPolicy = \"standby\";\n    }\n\n    return watchQueryOptions;\n  }, [client, options, query]);\n}\n", "import type {\n  ApolloClient,\n  OperationVariables,\n  WatchQueryFetchPolicy,\n} from \"@apollo/client\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nexport function validateSuspenseHookOptions<\n  TData,\n  TVariables extends OperationVariables,\n>(options: ApolloClient.WatchQueryOptions<TData, TVariables>) {\n  const { fetchPolicy, returnPartialData } = options;\n\n  validateFetchPolicy(fetchPolicy);\n  validatePartialDataReturn(fetchPolicy, returnPartialData);\n}\n\nfunction validateFetchPolicy(\n  fetchPolicy: WatchQueryFetchPolicy = \"cache-first\"\n) {\n  const supportedFetchPolicies: WatchQueryFetchPolicy[] = [\n    \"cache-first\",\n    \"network-only\",\n    \"no-cache\",\n    \"cache-and-network\",\n  ];\n\n  invariant(\n    supportedFetchPolicies.includes(fetchPolicy),\n    `The fetch policy \\`%s\\` is not supported with suspense.`,\n    fetchPolicy\n  );\n}\n\nfunction validatePartialDataReturn(\n  fetchPolicy: WatchQueryFetchPolicy | undefined,\n  returnPartialData: boolean | undefined\n) {\n  if (fetchPolicy === \"no-cache\" && returnPartialData) {\n    invariant.warn(\n      \"Using `returnPartialData` with a `no-cache` fetch policy has no effect. To read partial data from the cache, consider using an alternate fetch policy.\"\n    );\n  }\n}\n", "import * as React from \"react\";\n\nimport type {\n  ApolloClient,\n  DataState,\n  DefaultContext,\n  DocumentNode,\n  ErrorPolicy,\n  OperationVariables,\n  RefetchWritePolicy,\n  TypedDocumentNode,\n  WatchQueryFetchPolicy,\n} from \"@apollo/client\";\nimport type { SubscribeToMoreFunction } from \"@apollo/client\";\nimport { canonicalStringify } from \"@apollo/client/cache\";\nimport type { QueryRef } from \"@apollo/client/react\";\nimport type {\n  CacheKey,\n  FetchMoreFunction,\n  RefetchFunction,\n} from \"@apollo/client/react/internal\";\nimport {\n  getSuspenseCache,\n  unwrapQueryRef,\n  updateWrappedQueryRef,\n  wrapQueryRef,\n} from \"@apollo/client/react/internal\";\nimport type {\n  DocumentationTypes as UtilityDocumentationTypes,\n  NoInfer,\n  VariablesOption,\n} from \"@apollo/client/utilities/internal\";\n\nimport type { SkipToken } from \"./constants.js\";\nimport { wrapHook } from \"./internal/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { useWatchQueryOptions } from \"./useSuspenseQuery.js\";\n\nexport declare namespace useBackgroundQuery {\n  import _self = useBackgroundQuery;\n  export type FetchPolicy = Extract<\n    WatchQueryFetchPolicy,\n    \"cache-first\" | \"network-only\" | \"no-cache\" | \"cache-and-network\"\n  >;\n\n  export namespace Base {\n    export interface Options {\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#client:member} */\n      client?: ApolloClient;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#refetchWritePolicy_suspense:member} */\n      refetchWritePolicy?: RefetchWritePolicy;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#errorPolicy:member} */\n      errorPolicy?: ErrorPolicy;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#context:member} */\n      context?: DefaultContext;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#returnPartialData:member} */\n      returnPartialData?: boolean;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#fetchPolicy:member} */\n      fetchPolicy?: FetchPolicy;\n\n      /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#queryKey:member} */\n      queryKey?: string | number | any[];\n\n      /**\n       * {@inheritDoc @apollo/client!QueryOptionsDocumentation#skip_deprecated:member}\n       *\n       * @example Recommended usage of `skipToken`:\n       *\n       * ```ts\n       * import { skipToken, useBackgroundQuery } from \"@apollo/client\";\n       *\n       * const [queryRef] = useBackgroundQuery(\n       *   query,\n       *   id ? { variables: { id } } : skipToken\n       * );\n       * ```\n       */\n      skip?: boolean;\n    }\n  }\n\n  export type Options<\n    TVariables extends OperationVariables = OperationVariables,\n  > = Base.Options & VariablesOption<TVariables>;\n\n  export namespace DocumentationTypes {\n    namespace useBackgroundQuery {\n      export interface Options<\n        TVariables extends OperationVariables = OperationVariables,\n      > extends Base.Options,\n          UtilityDocumentationTypes.VariableOptions<TVariables> {}\n    }\n  }\n\n  export interface Result<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > {\n    /** {@inheritDoc @apollo/client!ObservableQuery#subscribeToMore:member(1)} */\n    subscribeToMore: SubscribeToMoreFunction<TData, TVariables>;\n\n    /**\n     * {@inheritDoc @apollo/client!ObservableQuery#fetchMore:member(1)}\n     *\n     * @remarks\n     * Calling this function will cause the component to re-suspend, unless the call site is wrapped in [`startTransition`](https://react.dev/reference/react/startTransition).\n     */\n    fetchMore: FetchMoreFunction<TData, TVariables>;\n\n    /**\n     * {@inheritDoc @apollo/client!QueryResultDocumentation#refetch:member}\n     *\n     * @remarks\n     * Calling this function will cause the component to re-suspend, unless the call site is wrapped in [`startTransition`](https://react.dev/reference/react/startTransition).\n     */\n    refetch: RefetchFunction<TData, TVariables>;\n  }\n\n  namespace DocumentationTypes {\n    namespace useBackgroundQuery {\n      export interface Result<\n        TData = unknown,\n        TVariables extends OperationVariables = OperationVariables,\n      > extends _self.Result<TData, TVariables> {}\n    }\n  }\n\n  export namespace DocumentationTypes {\n    /** {@inheritDoc @apollo/client/react!useBackgroundQuery:function(1)} */\n    export function useBackgroundQuery<\n      TData = unknown,\n      TVariables extends OperationVariables = OperationVariables,\n    >(\n      query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n      options: SkipToken | useBackgroundQuery.Options<TVariables>\n    ): [\n      QueryRef<TData, TVariables> | undefined,\n      useBackgroundQuery.Result<TData, TVariables>,\n    ];\n  }\n}\n\n/**\n * For a detailed explanation of useBackgroundQuery, see the [fetching with Suspense reference](https://www.apollographql.com/docs/react/data/suspense).\n *\n * @returns A tuple containing:\n *\n * 1.  A `QueryRef` that can be passed to `useReadQuery` to read the query result. The `queryRef` is `undefined` if the query is skipped.\n * 2.  An object containing helper functions for the query:\n *     - `refetch`: A function to re-execute the query\n *     - `fetchMore`: A function to fetch more results for pagination\n *     - `subscribeToMore`: A function to subscribe to updates\n *\n * @example\n *\n * ```jsx\n * import { Suspense } from \"react\";\n * import { ApolloClient, InMemoryCache, HttpLink } from \"@apollo/client\";\n * import { useBackgroundQuery, useReadQuery } from \"@apollo/client/react\";\n *\n * const query = gql`\n *   foo {\n *     bar\n *   }\n * `;\n *\n * const client = new ApolloClient({\n *   link: new HttpLink({ uri: \"http://localhost:4000/graphql\" }),\n *   cache: new InMemoryCache(),\n * });\n *\n * function SuspenseFallback() {\n *   return <div>Loading...</div>;\n * }\n *\n * function Child({ queryRef }) {\n *   const { data } = useReadQuery(queryRef);\n *\n *   return <div>{data.foo.bar}</div>;\n * }\n *\n * function Parent() {\n *   const [queryRef] = useBackgroundQuery(query);\n *\n *   return (\n *     <Suspense fallback={<SuspenseFallback />}>\n *       <Child queryRef={queryRef} />\n *     </Suspense>\n *   );\n * }\n *\n * function App() {\n *   return (\n *     <ApolloProvider client={client}>\n *       <Parent />\n *     </ApolloProvider>\n *   );\n * }\n * ```\n *\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - An optional object containing options for the query. Instead of passing a `useBackgroundQuery.Options` object into the hook, you can also pass a [`skipToken`](#skiptoken) to prevent the `useBackgroundQuery` hook from executing the query or suspending.\n */\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useBackgroundQuery.Options<NoInfer<TVariables>> & {\n    /** @deprecated `returnPartialData` has no effect on `no-cache` queries */\n    returnPartialData: boolean;\n    fetchPolicy: \"no-cache\";\n  }\n): [\n  QueryRef<TData, TVariables, \"complete\" | \"streaming\">,\n  useBackgroundQuery.Result<TData, TVariables>,\n];\n\n/** {@inheritDoc @apollo/client/react!useBackgroundQuery:function(1)} */\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useBackgroundQuery.Options<NoInfer<TVariables>> & {\n    returnPartialData: false;\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): [\n  QueryRef<TData, TVariables, \"complete\" | \"streaming\" | \"empty\">,\n  useBackgroundQuery.Result<TData, TVariables>,\n];\n\n/** {@inheritDoc @apollo/client/react!useBackgroundQuery:function(1)} */\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useBackgroundQuery.Options<NoInfer<TVariables>> & {\n    returnPartialData: boolean;\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): [\n  QueryRef<TData, TVariables, \"complete\" | \"streaming\" | \"partial\" | \"empty\">,\n  useBackgroundQuery.Result<TData, TVariables>,\n];\n\n/** {@inheritDoc @apollo/client/react!useBackgroundQuery:function(1)} */\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useBackgroundQuery.Options<NoInfer<TVariables>> & {\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): [\n  QueryRef<TData, TVariables, \"complete\" | \"streaming\" | \"empty\">,\n  useBackgroundQuery.Result<TData, TVariables>,\n];\n\n/** {@inheritDoc @apollo/client/react!useBackgroundQuery:function(1)} */\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useBackgroundQuery.Options<NoInfer<TVariables>> & {\n    skip: boolean;\n    returnPartialData: false;\n  }\n): [\n  QueryRef<TData, TVariables, \"complete\" | \"streaming\"> | undefined,\n  useBackgroundQuery.Result<TData, TVariables>,\n];\n\n/** {@inheritDoc @apollo/client/react!useBackgroundQuery:function(1)} */\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useBackgroundQuery.Options<NoInfer<TVariables>> & {\n    skip: boolean;\n    returnPartialData: boolean;\n  }\n): [\n  QueryRef<TData, TVariables, \"complete\" | \"streaming\" | \"partial\"> | undefined,\n  useBackgroundQuery.Result<TData, TVariables>,\n];\n\n/** {@inheritDoc @apollo/client/react!useBackgroundQuery:function(1)} */\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useBackgroundQuery.Options<NoInfer<TVariables>> & {\n    returnPartialData: false;\n  }\n): [\n  QueryRef<TData, TVariables, \"complete\" | \"streaming\">,\n  useBackgroundQuery.Result<TData, TVariables>,\n];\n\n/** {@inheritDoc @apollo/client/react!useBackgroundQuery:function(1)} */\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useBackgroundQuery.Options<NoInfer<TVariables>> & {\n    returnPartialData: boolean;\n  }\n): [\n  QueryRef<TData, TVariables, \"complete\" | \"streaming\" | \"partial\">,\n  useBackgroundQuery.Result<TData, TVariables>,\n];\n\n/** {@inheritDoc @apollo/client/react!useBackgroundQuery:function(1)} */\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useBackgroundQuery.Options<NoInfer<TVariables>> & {\n    skip: boolean;\n  }\n): [\n  QueryRef<TData, TVariables, \"complete\" | \"streaming\"> | undefined,\n  useBackgroundQuery.Result<TData, TVariables>,\n];\n\n/** {@inheritDoc @apollo/client/react!useBackgroundQuery:function(1)} */\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SkipToken\n): [undefined, useBackgroundQuery.Result<TData, TVariables>];\n\n/** {@inheritDoc @apollo/client/react!useBackgroundQuery:function(1)} */\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | SkipToken\n    | (useBackgroundQuery.Options<NoInfer<TVariables>> & {\n        returnPartialData: false;\n      })\n): [\n  QueryRef<TData, TVariables, \"complete\" | \"streaming\"> | undefined,\n  useBackgroundQuery.Result<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | SkipToken\n    | (useBackgroundQuery.Options<NoInfer<TVariables>> & {\n        returnPartialData: boolean;\n      })\n): [\n  QueryRef<TData, TVariables, \"complete\" | \"streaming\" | \"partial\"> | undefined,\n  useBackgroundQuery.Result<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  ...[options]: {} extends TVariables ?\n    [options?: useBackgroundQuery.Options<NoInfer<TVariables>>]\n  : [options: useBackgroundQuery.Options<NoInfer<TVariables>>]\n): [\n  QueryRef<TData, TVariables, \"complete\" | \"streaming\">,\n  useBackgroundQuery.Result<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  ...[options]: {} extends TVariables ?\n    [options?: SkipToken | useBackgroundQuery.Options<NoInfer<TVariables>>]\n  : [options: SkipToken | useBackgroundQuery.Options<NoInfer<TVariables>>]\n): [\n  QueryRef<TData, TVariables, \"complete\" | \"streaming\"> | undefined,\n  useBackgroundQuery.Result<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: SkipToken | useBackgroundQuery.Options<NoInfer<TVariables>>\n): [\n  QueryRef<TData, TVariables, \"complete\" | \"streaming\"> | undefined,\n  useBackgroundQuery.Result<TData, TVariables>,\n];\n\nexport function useBackgroundQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: SkipToken | useBackgroundQuery.Options<NoInfer<TVariables>>\n): [\n  QueryRef<TData, TVariables, DataState<TData>[\"dataState\"]> | undefined,\n  useBackgroundQuery.Result<TData, TVariables>,\n] {\n  \"use no memo\";\n  return wrapHook(\n    \"useBackgroundQuery\",\n    // eslint-disable-next-line react-compiler/react-compiler\n    useBackgroundQuery_,\n    useApolloClient(typeof options === \"object\" ? options.client : undefined)\n  )(query, options ?? ({} as any));\n}\n\nfunction useBackgroundQuery_<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n  TStates extends DataState<TData>[\"dataState\"] = DataState<TData>[\"dataState\"],\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options:\n    | (SkipToken & Partial<useBackgroundQuery.Options<NoInfer<TVariables>>>)\n    | useBackgroundQuery.Options<NoInfer<TVariables>>\n): [\n  QueryRef<TData, TVariables, TStates> | undefined,\n  useBackgroundQuery.Result<TData, TVariables>,\n] {\n  const client = useApolloClient(options.client);\n  const suspenseCache = getSuspenseCache(client);\n  const watchQueryOptions = useWatchQueryOptions({ client, query, options });\n  const { fetchPolicy, variables } = watchQueryOptions;\n  const { queryKey = [] } = options;\n\n  // This ref tracks the first time query execution is enabled to determine\n  // whether to return a query ref or `undefined`. When initialized\n  // in a skipped state (either via `skip: true` or `skipToken`) we return\n  // `undefined` for the `queryRef` until the query has been enabled. Once\n  // enabled, a query ref is always returned regardless of whether the query is\n  // skipped again later.\n  const didFetchResult = React.useRef(fetchPolicy !== \"standby\");\n  didFetchResult.current ||= fetchPolicy !== \"standby\";\n\n  const cacheKey: CacheKey = [\n    query,\n    canonicalStringify(variables),\n    ...([] as any[]).concat(queryKey),\n  ];\n\n  const queryRef = suspenseCache.getQueryRef<TData, TStates>(cacheKey, () =>\n    client.watchQuery(\n      watchQueryOptions as ApolloClient.WatchQueryOptions<any, any>\n    )\n  );\n\n  const [wrappedQueryRef, setWrappedQueryRef] = React.useState(\n    wrapQueryRef(queryRef)\n  );\n  if (unwrapQueryRef(wrappedQueryRef) !== queryRef) {\n    setWrappedQueryRef(wrapQueryRef(queryRef));\n  }\n  if (queryRef.didChangeOptions(watchQueryOptions)) {\n    const promise = queryRef.applyOptions(watchQueryOptions);\n    updateWrappedQueryRef(wrappedQueryRef, promise);\n  }\n\n  // This prevents issues where rerendering useBackgroundQuery after the\n  // queryRef has been disposed would cause the hook to return a new queryRef\n  // instance since disposal also removes it from the suspense cache. We add\n  // the queryRef back in the suspense cache so that the next render will reuse\n  // this queryRef rather than initializing a new instance.\n  React.useEffect(() => {\n    // Since the queryRef is disposed async via `setTimeout`, we have to wait a\n    // tick before checking it and adding back to the suspense cache.\n    const id = setTimeout(() => {\n      if (queryRef.disposed) {\n        suspenseCache.add(cacheKey, queryRef);\n      }\n    });\n\n    return () => clearTimeout(id);\n    // Omitting the deps is intentional. This avoids stale closures and the\n    // conditional ensures we aren't running the logic on each render.\n  });\n\n  const fetchMore: FetchMoreFunction<TData, TVariables> = React.useCallback(\n    (options) => {\n      const promise = queryRef.fetchMore(options);\n\n      setWrappedQueryRef(wrapQueryRef(queryRef));\n\n      return promise;\n    },\n    [queryRef]\n  );\n\n  const refetch: RefetchFunction<TData, TVariables> = React.useCallback(\n    (variables) => {\n      const promise = queryRef.refetch(variables);\n\n      setWrappedQueryRef(wrapQueryRef(queryRef));\n\n      return promise;\n    },\n    [queryRef]\n  );\n\n  React.useEffect(() => queryRef.softRetain(), [queryRef]);\n\n  return [\n    didFetchResult.current ? wrappedQueryRef : void 0,\n    {\n      fetchMore,\n      refetch,\n      // TODO: The internalQueryRef doesn't have TVariables' type information so we have to cast it here\n      subscribeToMore: queryRef.observable\n        .subscribeToMore as SubscribeToMoreFunction<TData, TVariables>,\n    },\n  ];\n}\n", "import * as React from \"react\";\n\nimport type {\n  ApolloClient,\n  DataValue,\n  DocumentNode,\n  OperationVariables,\n  Reference,\n  StoreObject,\n  TypedDocumentNode,\n} from \"@apollo/client\";\nimport { canonicalStringify } from \"@apollo/client/cache\";\nimport type { FragmentType, MaybeMasked } from \"@apollo/client/masking\";\nimport type { FragmentKey } from \"@apollo/client/react/internal\";\nimport { getSuspenseCache } from \"@apollo/client/react/internal\";\nimport type {\n  DocumentationTypes as UtilityDocumentationTypes,\n  NoInfer,\n  VariablesOption,\n} from \"@apollo/client/utilities/internal\";\n\nimport { __use } from \"./internal/__use.js\";\nimport { wrapHook } from \"./internal/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\n\ntype From<TData> =\n  | StoreObject\n  | Reference\n  | FragmentType<NoInfer<TData>>\n  | string\n  | null;\n\nexport declare namespace useSuspenseFragment {\n  import _self = useSuspenseFragment;\n  export namespace Base {\n    export type Options<TData, TVariables extends OperationVariables> = {\n      /**\n       * A GraphQL document created using the `gql` template string tag from\n       * `graphql-tag` with one or more fragments which will be used to determine\n       * the shape of data to read. If you provide more than one fragment in this\n       * document then you must also specify `fragmentName` to select a single.\n       */\n      fragment: DocumentNode | TypedDocumentNode<TData, TVariables>;\n\n      /**\n       * The name of the fragment in your GraphQL document to be used. If you do\n       * not provide a `fragmentName` and there is only one fragment in your\n       * `fragment` document then that fragment will be used.\n       */\n      fragmentName?: string;\n      from: From<TData>;\n      // Override this field to make it optional (default: true).\n      optimistic?: boolean;\n      /**\n       * The instance of `ApolloClient` to use to look up the fragment.\n       *\n       * By default, the instance that's passed down via context is used, but you\n       * can provide a different instance here.\n       *\n       * @docGroup 1. Operation options\n       */\n      client?: ApolloClient;\n    };\n  }\n  export type Options<\n    TData,\n    TVariables extends OperationVariables,\n  > = Base.Options<TData, TVariables> & VariablesOption<NoInfer<TVariables>>;\n\n  export namespace DocumentationTypes {\n    export namespace useSuspenseFragment {\n      export interface Options<\n        TData = unknown,\n        TVariables extends OperationVariables = OperationVariables,\n      > extends Base.Options<TData, TVariables>,\n          UtilityDocumentationTypes.VariableOptions<TVariables> {}\n    }\n  }\n\n  export interface Result<TData> {\n    data: DataValue.Complete<MaybeMasked<TData>>;\n  }\n  export namespace DocumentationTypes {\n    export namespace useSuspenseFragment {\n      export interface Result<TData = unknown> extends _self.Result<TData> {}\n    }\n  }\n\n  export namespace DocumentationTypes {\n    /** {@inheritDoc @apollo/client/react!useSuspenseFragment:function(1)} */\n    export function useSuspenseFragment<\n      TData,\n      TVariables extends OperationVariables = OperationVariables,\n    >(\n      options: useSuspenseFragment.Options<TData, TVariables>\n    ): useSuspenseFragment.Result<TData>;\n  }\n}\n\nconst NULL_PLACEHOLDER = [] as unknown as [\n  FragmentKey,\n  Promise<MaybeMasked<any> | null>,\n];\n\n/** #TODO documentation */\nexport function useSuspenseFragment<\n  TData,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  options: useSuspenseFragment.Options<TData, TVariables> & {\n    from: NonNullable<From<TData>>;\n  }\n): useSuspenseFragment.Result<TData>;\n\n/** {@inheritDoc @apollo/client/react!useSuspenseFragment:function(1)} */\nexport function useSuspenseFragment<\n  TData,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  options: useSuspenseFragment.Options<TData, TVariables> & {\n    from: null;\n  }\n): useSuspenseFragment.Result<null>;\n\n/** {@inheritDoc @apollo/client/react!useSuspenseFragment:function(1)} */\nexport function useSuspenseFragment<\n  TData,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  options: useSuspenseFragment.Options<TData, TVariables> & {\n    from: From<TData>;\n  }\n): useSuspenseFragment.Result<TData | null>;\n\n/** {@inheritDoc @apollo/client/react!useSuspenseFragment:function(1)} */\nexport function useSuspenseFragment<\n  TData,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  options: useSuspenseFragment.Options<TData, TVariables>\n): useSuspenseFragment.Result<TData>;\n\nexport function useSuspenseFragment<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  options: useSuspenseFragment.Options<TData, TVariables>\n): useSuspenseFragment.Result<TData | null> {\n  \"use no memo\";\n  return wrapHook(\n    \"useSuspenseFragment\",\n    // eslint-disable-next-line react-compiler/react-compiler\n    useSuspenseFragment_,\n    useApolloClient(typeof options === \"object\" ? options.client : undefined)\n  )(options);\n}\n\nfunction useSuspenseFragment_<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  options: useSuspenseFragment.Options<TData, TVariables>\n): useSuspenseFragment.Result<TData | null> {\n  const client = useApolloClient(options.client);\n  const { from, variables } = options;\n  const { cache } = client;\n\n  const id = React.useMemo(\n    () =>\n      typeof from === \"string\" ? from\n      : from === null ? null\n      : cache.identify(from),\n    [cache, from]\n  ) as string | null;\n\n  const fragmentRef =\n    id === null ? null : (\n      getSuspenseCache(client).getFragmentRef(\n        [id, options.fragment, canonicalStringify(variables)],\n        client,\n        { ...options, variables: variables as TVariables, from: id }\n      )\n    );\n\n  let [current, setPromise] = React.useState<\n    [FragmentKey, Promise<MaybeMasked<TData> | null>]\n  >(\n    fragmentRef === null ? NULL_PLACEHOLDER : (\n      [fragmentRef.key, fragmentRef.promise]\n    )\n  );\n\n  React.useEffect(() => {\n    if (fragmentRef === null) {\n      return;\n    }\n\n    const dispose = fragmentRef.retain();\n    const removeListener = fragmentRef.listen((promise) => {\n      setPromise([fragmentRef.key, promise]);\n    });\n\n    return () => {\n      dispose();\n      removeListener();\n    };\n  }, [fragmentRef]);\n\n  if (fragmentRef === null) {\n    return { data: null };\n  }\n\n  if (current[0] !== fragmentRef.key) {\n    // eslint-disable-next-line react-compiler/react-compiler\n    current[0] = fragmentRef.key;\n    current[1] = fragmentRef.promise;\n  }\n\n  const data = __use(current[1]);\n\n  return { data };\n}\n", "import * as React from \"react\";\n\nimport type {\n  ApolloClient,\n  DataState,\n  DefaultContext,\n  DocumentNode,\n  ErrorPolicy,\n  ObservableQuery,\n  OperationVariables,\n  RefetchWritePolicy,\n  TypedDocumentNode,\n  WatchQueryFetchPolicy,\n} from \"@apollo/client\";\nimport type { SubscribeToMoreFunction } from \"@apollo/client\";\nimport { canonicalStringify } from \"@apollo/client/cache\";\nimport type { QueryRef } from \"@apollo/client/react\";\nimport type {\n  CacheKey,\n  FetchMoreFunction,\n  RefetchFunction,\n} from \"@apollo/client/react/internal\";\nimport {\n  assertWrappedQueryRef,\n  getSuspenseCache,\n  unwrapQueryRef,\n  updateWrappedQueryRef,\n  wrapQueryRef,\n} from \"@apollo/client/react/internal\";\nimport { __DEV__ } from \"@apollo/client/utilities/environment\";\nimport { invariant } from \"@apollo/client/utilities/invariant\";\n\nimport { __use, useDeepMemo, useRenderGuard } from \"./internal/index.js\";\nimport { validateSuspenseHookOptions } from \"./internal/validateSuspenseHookOptions.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\n\ntype ResetFunction = () => void;\n\nexport declare namespace useLoadableQuery {\n  export type LoadQueryFunction<TVariables extends OperationVariables> = (\n    // Use variadic args to handle cases where TVariables is type `never`, in\n    // which case we don't want to allow a variables argument. In other\n    // words, we don't want to allow variables to be passed as an argument to this\n    // function if the query does not expect variables in the document.\n    ...args: {} extends TVariables ? [variables?: TVariables]\n    : [variables: TVariables]\n  ) => void;\n\n  export type Result<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n    TStates extends\n      DataState<TData>[\"dataState\"] = DataState<TData>[\"dataState\"],\n  > = [\n    loadQuery: LoadQueryFunction<TVariables>,\n    queryRef: QueryRef<TData, TVariables, TStates> | null,\n    handlers: Handlers<TData, TVariables>,\n  ];\n  export interface Handlers<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > {\n    /** {@inheritDoc @apollo/client!QueryResultDocumentation#fetchMore:member} */\n    fetchMore: FetchMoreFunction<TData, TVariables>;\n    /** {@inheritDoc @apollo/client!QueryResultDocumentation#refetch:member} */\n    refetch: RefetchFunction<TData, TVariables>;\n    /** {@inheritDoc @apollo/client!ObservableQuery#subscribeToMore:member(1)} */\n    subscribeToMore: SubscribeToMoreFunction<TData, TVariables>;\n    /**\n     * A function that resets the `queryRef` back to `null`.\n     */\n    reset: ResetFunction;\n  }\n\n  export type FetchPolicy = Extract<\n    WatchQueryFetchPolicy,\n    \"cache-first\" | \"network-only\" | \"no-cache\" | \"cache-and-network\"\n  >;\n\n  export interface Options {\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#client:member} */\n    client?: ApolloClient;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#context:member} */\n    context?: DefaultContext;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#errorPolicy:member} */\n    errorPolicy?: ErrorPolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#fetchPolicy:member} */\n    fetchPolicy?: FetchPolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#queryKey:member} */\n    queryKey?: string | number | any[];\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#refetchWritePolicy:member} */\n    refetchWritePolicy?: RefetchWritePolicy;\n\n    /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#returnPartialData:member} */\n    returnPartialData?: boolean;\n  }\n\n  export namespace DocumentationTypes {\n    /** {@inheritDoc @apollo/client/react!useLoadableQuery:function(1)} */\n    export function useLoadableQuery<\n      TData = unknown,\n      TVariables extends OperationVariables = OperationVariables,\n    >(\n      query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n      options: useLoadableQuery.Options\n    ): useLoadableQuery.Result<TData, TVariables>;\n  }\n}\n\n/**\n * A hook for imperatively loading a query, such as responding to a user\n * interaction.\n *\n * > Refer to the [Suspense - Fetching in response to user interaction](https://www.apollographql.com/docs/react/data/suspense#fetching-in-response-to-user-interaction) section for a more in-depth overview of `useLoadableQuery`.\n *\n * @example\n *\n * ```jsx\n * import { gql, useLoadableQuery } from \"@apollo/client\";\n *\n * const GET_GREETING = gql`\n *   query GetGreeting($language: String!) {\n *     greeting(language: $language) {\n *       message\n *     }\n *   }\n * `;\n *\n * function App() {\n *   const [loadGreeting, queryRef] = useLoadableQuery(GET_GREETING);\n *\n *   return (\n *     <>\n *       <button onClick={() => loadGreeting({ language: \"english\" })}>\n *         Load greeting\n *       </button>\n *       <Suspense fallback={<div>Loading...</div>}>\n *         {queryRef && <Hello queryRef={queryRef} />}\n *       </Suspense>\n *     </>\n *   );\n * }\n *\n * function Hello({ queryRef }) {\n *   const { data } = useReadQuery(queryRef);\n *\n *   return <div>{data.greeting.message}</div>;\n * }\n * ```\n *\n * @param query - A GraphQL query document parsed into an AST by `gql`.\n * @param options - Options to control how the query is executed.\n * @returns A tuple in the form of `[loadQuery, queryRef, handlers]`\n */\nexport function useLoadableQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useLoadableQuery.Options & {\n    returnPartialData: true;\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): useLoadableQuery.Result<\n  TData,\n  TVariables,\n  \"complete\" | \"streaming\" | \"partial\" | \"empty\"\n>;\n\n/** {@inheritDoc @apollo/client/react!useLoadableQuery:function(1)} */\nexport function useLoadableQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useLoadableQuery.Options & {\n    errorPolicy: \"ignore\" | \"all\";\n  }\n): useLoadableQuery.Result<\n  TData,\n  TVariables,\n  \"complete\" | \"streaming\" | \"empty\"\n>;\n\n/** {@inheritDoc @apollo/client/react!useLoadableQuery:function(1)} */\nexport function useLoadableQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useLoadableQuery.Options & {\n    returnPartialData: true;\n  }\n): useLoadableQuery.Result<\n  TData,\n  TVariables,\n  \"complete\" | \"streaming\" | \"partial\"\n>;\n\n/** {@inheritDoc @apollo/client/react!useLoadableQuery:function(1)} */\nexport function useLoadableQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: useLoadableQuery.Options\n): useLoadableQuery.Result<TData, TVariables, \"complete\" | \"streaming\">;\n\nexport function useLoadableQuery<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options: useLoadableQuery.Options = {}\n): useLoadableQuery.Result<TData, TVariables> {\n  const client = useApolloClient(options.client);\n  const suspenseCache = getSuspenseCache(client);\n  const watchQueryOptions = useWatchQueryOptions({ client, query, options });\n  const { queryKey = [] } = options;\n\n  const [queryRef, setQueryRef] = React.useState<QueryRef<\n    TData,\n    TVariables,\n    DataState<TData>[\"dataState\"]\n  > | null>(null);\n\n  assertWrappedQueryRef(queryRef);\n\n  const internalQueryRef = queryRef && unwrapQueryRef(queryRef);\n\n  if (queryRef && internalQueryRef?.didChangeOptions(watchQueryOptions)) {\n    const promise = internalQueryRef.applyOptions(watchQueryOptions);\n    updateWrappedQueryRef(queryRef, promise);\n  }\n\n  const calledDuringRender = useRenderGuard();\n\n  const fetchMore: FetchMoreFunction<TData, TVariables> = React.useCallback(\n    (options) => {\n      if (!internalQueryRef) {\n        throw new Error(\n          \"The query has not been loaded. Please load the query.\"\n        );\n      }\n\n      const promise = internalQueryRef.fetchMore(options);\n\n      setQueryRef(wrapQueryRef(internalQueryRef));\n\n      return promise;\n    },\n    [internalQueryRef]\n  );\n\n  const refetch: RefetchFunction<TData, TVariables> = React.useCallback(\n    (options) => {\n      if (!internalQueryRef) {\n        throw new Error(\n          \"The query has not been loaded. Please load the query.\"\n        );\n      }\n\n      const promise = internalQueryRef.refetch(options);\n\n      setQueryRef(wrapQueryRef(internalQueryRef));\n\n      return promise;\n    },\n    [internalQueryRef]\n  );\n\n  const loadQuery: useLoadableQuery.LoadQueryFunction<TVariables> =\n    React.useCallback(\n      (...args) => {\n        invariant(\n          !calledDuringRender(),\n          \"useLoadableQuery: 'loadQuery' should not be called during render. To start a query during render, use the 'useBackgroundQuery' hook.\"\n        );\n\n        const [variables] = args;\n\n        const cacheKey: CacheKey = [\n          query,\n          canonicalStringify(variables),\n          ...([] as any[]).concat(queryKey),\n        ];\n\n        const queryRef = suspenseCache.getQueryRef(cacheKey, () =>\n          client.watchQuery({\n            ...watchQueryOptions,\n            variables,\n          } as ApolloClient.WatchQueryOptions<any, any>)\n        );\n\n        setQueryRef(wrapQueryRef(queryRef));\n      },\n      [\n        query,\n        queryKey,\n        suspenseCache,\n        watchQueryOptions,\n        calledDuringRender,\n        client,\n      ]\n    );\n\n  const subscribeToMore: SubscribeToMoreFunction<TData, TVariables> =\n    React.useCallback(\n      (options) => {\n        invariant(\n          internalQueryRef,\n          \"The query has not been loaded. Please load the query.\"\n        );\n\n        return internalQueryRef.observable.subscribeToMore(\n          // TODO: The internalQueryRef doesn't have TVariables' type information so we have to cast it here\n          options as any as ObservableQuery.SubscribeToMoreOptions<\n            TData,\n            OperationVariables\n          >\n        );\n      },\n      [internalQueryRef]\n    );\n\n  const reset: ResetFunction = React.useCallback(() => {\n    setQueryRef(null);\n  }, []);\n\n  return [loadQuery, queryRef, { fetchMore, refetch, reset, subscribeToMore }];\n}\n\nfunction useWatchQueryOptions<TData, TVariables extends OperationVariables>({\n  client,\n  query,\n  options,\n}: {\n  client: ApolloClient;\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>;\n  options: useLoadableQuery.Options;\n}): ApolloClient.WatchQueryOptions<TData, TVariables> {\n  return useDeepMemo<ApolloClient.WatchQueryOptions<TData, TVariables>>(() => {\n    const fetchPolicy =\n      options.fetchPolicy ||\n      client.defaultOptions.watchQuery?.fetchPolicy ||\n      \"cache-first\";\n\n    const watchQueryOptions = {\n      ...options,\n      fetchPolicy,\n      query,\n      notifyOnNetworkStatusChange: false,\n      nextFetchPolicy: void 0,\n    };\n\n    if (__DEV__) {\n      validateSuspenseHookOptions(watchQueryOptions as any);\n    }\n\n    return watchQueryOptions as ApolloClient.WatchQueryOptions<\n      TData,\n      TVariables\n    >;\n  }, [client, options, query]);\n}\n", "import * as React from \"react\";\n\nimport type { DataState, OperationVariables } from \"@apollo/client\";\nimport type { SubscribeToMoreFunction } from \"@apollo/client\";\nimport type { ApolloClient } from \"@apollo/client\";\nimport type { ObservableQuery } from \"@apollo/client\";\nimport type { QueryRef } from \"@apollo/client/react\";\nimport type {\n  FetchMoreFunction,\n  RefetchFunction,\n} from \"@apollo/client/react/internal\";\nimport {\n  assertWrappedQueryRef,\n  getWrappedPromise,\n  unwrapQueryRef,\n  updateWrappedQueryRef,\n  wrapQueryRef,\n} from \"@apollo/client/react/internal\";\n\nimport { wrapHook } from \"./internal/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\n\nexport declare namespace useQueryRefHandlers {\n  export interface Result<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  > {\n    /** {@inheritDoc @apollo/client!ObservableQuery#refetch:member(1)} */\n    refetch: RefetchFunction<TData, TVariables>;\n    /** {@inheritDoc @apollo/client!ObservableQuery#fetchMore:member(1)} */\n    fetchMore: FetchMoreFunction<TData, TVariables>;\n    /** {@inheritDoc @apollo/client!ObservableQuery#subscribeToMore:member(1)} */\n    subscribeToMore: SubscribeToMoreFunction<TData, TVariables>;\n  }\n\n  export namespace DocumentationTypes {\n    /** {@inheritDoc @apollo/client/react!useQueryRefHandlers:function(1)} */\n    export function useQueryRefHandlers<\n      TData = unknown,\n      TVariables extends OperationVariables = OperationVariables,\n    >(\n      queryRef: QueryRef<TData, TVariables>\n    ): useQueryRefHandlers.Result<TData, TVariables>;\n  }\n}\n\n/**\n * A React hook that returns a `refetch` and `fetchMore` function for a given\n * `queryRef`.\n *\n * This is useful to get access to handlers for a `queryRef` that was created by\n * `createQueryPreloader` or when the handlers for a `queryRef` produced in\n * a different component are inaccessible.\n *\n * @example\n *\n * ```tsx\n * const MyComponent({ queryRef }) {\n *   const { refetch, fetchMore } = useQueryRefHandlers(queryRef);\n *\n *   // ...\n * }\n * ```\n *\n * @param queryRef - A `QueryRef` returned from `useBackgroundQuery`, `useLoadableQuery`, or `createQueryPreloader`.\n */\nexport function useQueryRefHandlers<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  queryRef: QueryRef<TData, TVariables, DataState<TData>[\"dataState\"]>\n): useQueryRefHandlers.Result<TData, TVariables> {\n  \"use no memo\";\n  const unwrapped = unwrapQueryRef(queryRef);\n  const clientOrObsQuery = useApolloClient(\n    unwrapped ?\n      // passing an `ObservableQuery` is not supported by the types, but it will\n      // return any truthy value that is passed in as an override so we cast the result\n      (unwrapped[\"observable\"] as any)\n    : undefined\n  ) as ApolloClient | ObservableQuery<TData>;\n\n  return wrapHook(\n    \"useQueryRefHandlers\",\n    // eslint-disable-next-line react-compiler/react-compiler\n    useQueryRefHandlers_,\n    clientOrObsQuery\n  )(queryRef);\n}\n\nfunction useQueryRefHandlers_<\n  TData = unknown,\n  TVariables extends OperationVariables = OperationVariables,\n>(\n  queryRef: QueryRef<TData, TVariables, DataState<TData>[\"dataState\"]>\n): useQueryRefHandlers.Result<TData, TVariables> {\n  assertWrappedQueryRef(queryRef);\n  const [previousQueryRef, setPreviousQueryRef] = React.useState(queryRef);\n  const [wrappedQueryRef, setWrappedQueryRef] = React.useState(queryRef);\n  const internalQueryRef = unwrapQueryRef(queryRef);\n\n  // To ensure we can support React transitions, this hook needs to manage the\n  // queryRef state and apply React's state value immediately to the existing\n  // queryRef since this hook doesn't return the queryRef directly\n  if (previousQueryRef !== queryRef) {\n    setPreviousQueryRef(queryRef);\n    setWrappedQueryRef(queryRef);\n  } else {\n    updateWrappedQueryRef(queryRef, getWrappedPromise(wrappedQueryRef));\n  }\n\n  const refetch: RefetchFunction<TData, TVariables> = React.useCallback(\n    (variables) => {\n      const promise = internalQueryRef.refetch(variables);\n\n      setWrappedQueryRef(wrapQueryRef(internalQueryRef));\n\n      return promise;\n    },\n    [internalQueryRef]\n  );\n\n  const fetchMore: FetchMoreFunction<TData, TVariables> = React.useCallback(\n    (options) => {\n      const promise = internalQueryRef.fetchMore(\n        options as ObservableQuery.FetchMoreOptions<any, any>\n      );\n\n      setWrappedQueryRef(wrapQueryRef(internalQueryRef));\n\n      return promise;\n    },\n    [internalQueryRef]\n  );\n\n  return {\n    refetch,\n    fetchMore,\n    // TODO: The internalQueryRef doesn't have TVariables' type information so we have to cast it here\n    subscribeToMore: internalQueryRef.observable\n      .subscribeToMore as SubscribeToMoreFunction<TData, TVariables>,\n  };\n}\n", "import * as React from \"react\";\n\nimport type {\n  ApolloClient,\n  DataState,\n  ErrorLike,\n  GetDataState,\n  NetworkStatus,\n  ObservableQuery,\n} from \"@apollo/client\";\nimport type { MaybeMasked } from \"@apollo/client/masking\";\nimport type { QueryRef } from \"@apollo/client/react\";\nimport {\n  assertWrappedQueryRef,\n  getWrappedPromise,\n  unwrapQueryRef,\n  updateWrappedQueryRef,\n} from \"@apollo/client/react/internal\";\nimport type { DocumentationTypes as UtilityDocumentationTypes } from \"@apollo/client/utilities/internal\";\n\nimport { __use, wrapHook } from \"./internal/index.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nimport { useSyncExternalStore } from \"./useSyncExternalStore.js\";\n\nexport declare namespace useReadQuery {\n  export namespace Base {\n    export interface Result<TData = unknown> {\n      /**\n       * {@inheritDoc @apollo/client!QueryResultDocumentation#error:member}\n       *\n       * This property can be ignored when using the default `errorPolicy` or an\n       * `errorPolicy` of `none`. The hook will throw the error instead of setting\n       * this property.\n       */\n      error: ErrorLike | undefined;\n      /** {@inheritDoc @apollo/client!QueryResultDocumentation#networkStatus:member} */\n      networkStatus: NetworkStatus;\n    }\n  }\n  export type Result<\n    TData = unknown,\n    TStates extends\n      DataState<TData>[\"dataState\"] = DataState<TData>[\"dataState\"],\n  > = Base.Result<TData> & GetDataState<MaybeMasked<TData>, TStates>;\n\n  export namespace DocumentationTypes {\n    namespace useReadQuery {\n      export interface Result<TData = unknown>\n        extends Base.Result<TData>,\n          UtilityDocumentationTypes.DataState<TData> {}\n    }\n\n    /** {@inheritDoc @apollo/client/react!useReadQuery:function(1)} */\n    export function useReadQuery<TData>(\n      queryRef: QueryRef<TData>\n    ): useReadQuery.Result<TData>;\n  }\n}\n\n/**\n * For a detailed explanation of `useReadQuery`, see the [fetching with Suspense reference](https://www.apollographql.com/docs/react/data/suspense#avoiding-request-waterfalls).\n *\n * @param queryRef - The `QueryRef` that was generated via `useBackgroundQuery`.\n * @returns An object containing the query result data, error, and network status.\n *\n * @example\n *\n * ```jsx\n * import { Suspense } from \"react\";\n * import { useBackgroundQuery, useReadQuery } from \"@apollo/client\";\n *\n * function Parent() {\n *   const [queryRef] = useBackgroundQuery(query);\n *\n *   return (\n *     <Suspense fallback={<div>Loading...</div>}>\n *       <Child queryRef={queryRef} />\n *     </Suspense>\n *   );\n * }\n *\n * function Child({ queryRef }) {\n *   const { data } = useReadQuery(queryRef);\n *\n *   return <div>{data.name}</div>;\n * }\n * ```\n */\nexport function useReadQuery<\n  TData,\n  TStates extends DataState<TData>[\"dataState\"],\n>(\n  queryRef: QueryRef<TData, any, TStates>\n): useReadQuery.Result<TData, TStates> {\n  \"use no memo\";\n  const unwrapped = unwrapQueryRef(queryRef);\n  const clientOrObsQuery = useApolloClient(\n    unwrapped ?\n      // passing an `ObservableQuery` is not supported by the types, but it will\n      // return any truthy value that is passed in as an override so we cast the result\n      (unwrapped[\"observable\"] as any)\n    : undefined\n  ) as ApolloClient | ObservableQuery<TData>;\n\n  return wrapHook(\n    \"useReadQuery\",\n    // eslint-disable-next-line react-compiler/react-compiler\n    useReadQuery_,\n    clientOrObsQuery\n  )(queryRef);\n}\n\nfunction useReadQuery_<TData, TStates extends DataState<TData>[\"dataState\"]>(\n  queryRef: QueryRef<TData, any, TStates>\n): useReadQuery.Result<TData, TStates> {\n  assertWrappedQueryRef(queryRef);\n  const internalQueryRef = React.useMemo(\n    () => unwrapQueryRef(queryRef),\n    [queryRef]\n  );\n\n  const getPromise = React.useCallback(\n    () => getWrappedPromise(queryRef),\n    [queryRef]\n  );\n\n  if (internalQueryRef.disposed) {\n    internalQueryRef.reinitialize();\n    updateWrappedQueryRef(queryRef, internalQueryRef.promise);\n  }\n\n  React.useEffect(() => internalQueryRef.retain(), [internalQueryRef]);\n\n  const promise = useSyncExternalStore(\n    React.useCallback(\n      (forceUpdate) => {\n        return internalQueryRef.listen((promise) => {\n          updateWrappedQueryRef(queryRef, promise);\n          forceUpdate();\n        });\n      },\n      [internalQueryRef, queryRef]\n    ),\n    getPromise,\n    getPromise\n  );\n\n  const result = __use(promise);\n\n  return React.useMemo(() => {\n    return {\n      data: result.data,\n      dataState: result.dataState,\n      networkStatus: result.networkStatus,\n      error: result.error,\n    } as useReadQuery.Result<TData, TStates>;\n  }, [result]);\n}\n", "import type {\n  ApolloClient,\n  DefaultContext,\n  DocumentNode,\n  ErrorPolicy,\n  OperationVariables,\n  RefetchWritePolicy,\n  TypedDocumentNode,\n  WatchQueryFetchPolicy,\n} from \"@apollo/client\";\nimport type { PreloadedQueryRef } from \"@apollo/client/react\";\nimport {\n  assertWrappedQueryRef,\n  getWrappedPromise,\n  InternalQueryReference,\n  wrapQueryRef,\n} from \"@apollo/client/react/internal\";\nimport type {\n  NoInfer,\n  VariablesOption,\n} from \"@apollo/client/utilities/internal\";\n\nimport { wrapHook } from \"../hooks/internal/index.js\";\n\nexport type PreloadQueryFetchPolicy = Extract<\n  WatchQueryFetchPolicy,\n  \"cache-first\" | \"network-only\" | \"no-cache\" | \"cache-and-network\"\n>;\n\nexport type PreloadQueryOptions<\n  TVariables extends OperationVariables = OperationVariables,\n> = {\n  /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#context:member} */\n  context?: DefaultContext;\n  /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#errorPolicy:member} */\n  errorPolicy?: ErrorPolicy;\n  /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#fetchPolicy:member} */\n  fetchPolicy?: PreloadQueryFetchPolicy;\n  /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#returnPartialData:member} */\n  returnPartialData?: boolean;\n  /** {@inheritDoc @apollo/client!QueryOptionsDocumentation#refetchWritePolicy:member} */\n  refetchWritePolicy?: RefetchWritePolicy;\n} & VariablesOption<TVariables>;\n\n/**\n * A function that will begin loading a query when called. It's result can be\n * read by `useReadQuery` which will suspend until the query is loaded.\n * This is useful when you want to start loading a query as early as possible\n * outside of a React component.\n *\n * @example\n *\n * ```js\n * const preloadQuery = createQueryPreloader(client);\n * const queryRef = preloadQuery(query, { variables, ...otherOptions });\n *\n * function App() {\n *   return (\n *     <Suspense fallback={<div>Loading</div>}>\n *       <MyQuery />\n *     </Suspense>\n *   );\n * }\n *\n * function MyQuery() {\n *   const { data } = useReadQuery(queryRef);\n *\n *   // do something with `data`\n * }\n * ```\n */\nexport interface PreloadQueryFunction {\n  /** {@inheritDoc @apollo/client/react!PreloadQueryFunction:interface} */\n  <TData = unknown, TVariables extends OperationVariables = OperationVariables>(\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    options: PreloadQueryOptions<NoInfer<TVariables>> & {\n      returnPartialData: true;\n      errorPolicy: \"ignore\" | \"all\";\n    }\n  ): PreloadedQueryRef<\n    TData,\n    TVariables,\n    \"complete\" | \"streaming\" | \"partial\" | \"empty\"\n  >;\n\n  /** {@inheritDoc @apollo/client/react!PreloadQueryFunction:interface} */\n  <TData = unknown, TVariables extends OperationVariables = OperationVariables>(\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    options: PreloadQueryOptions<NoInfer<TVariables>> & {\n      errorPolicy: \"ignore\" | \"all\";\n    }\n  ): PreloadedQueryRef<TData, TVariables, \"complete\" | \"streaming\" | \"empty\">;\n\n  /** {@inheritDoc @apollo/client/react!PreloadQueryFunction:interface} */\n  <TData = unknown, TVariables extends OperationVariables = OperationVariables>(\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    options: PreloadQueryOptions<NoInfer<TVariables>> & {\n      returnPartialData: true;\n    }\n  ): PreloadedQueryRef<TData, TVariables, \"complete\" | \"streaming\" | \"partial\">;\n\n  /** {@inheritDoc @apollo/client/react!PreloadQueryFunction:interface} */\n  <TData = unknown, TVariables extends OperationVariables = OperationVariables>(\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    ...[options]: {} extends TVariables ?\n      [options?: PreloadQueryOptions<NoInfer<TVariables>>]\n    : [options: PreloadQueryOptions<NoInfer<TVariables>>]\n  ): PreloadedQueryRef<TData, TVariables, \"complete\" | \"streaming\">;\n\n  /**\n   * A function that returns a promise that resolves when the query has finished\n   * loading. The promise resolves with the `QueryReference` itself.\n   *\n   * @remarks\n   * This method is useful for preloading queries in data loading routers, such\n   * as [React Router](https://reactrouter.com/en/main) or [TanStack Router](https://tanstack.com/router),\n   * to prevent routes from transitioning until the query has finished loading.\n   * `data` is not exposed on the promise to discourage using the data in\n   * `loader` functions and exposing it to your route components. Instead, we\n   * prefer you rely on `useReadQuery` to access the data to ensure your\n   * component can rerender with cache updates. If you need to access raw query\n   * data, use `client.query()` directly.\n   *\n   * @example\n   * Here's an example using React Router's `loader` function:\n   *\n   * ```ts\n   * import { createQueryPreloader } from \"@apollo/client\";\n   *\n   * const preloadQuery = createQueryPreloader(client);\n   *\n   * export async function loader() {\n   *   const queryRef = preloadQuery(GET_DOGS_QUERY);\n   *\n   *   return preloadQuery.toPromise(queryRef);\n   * }\n   *\n   * export function RouteComponent() {\n   *   const queryRef = useLoaderData();\n   *   const { data } = useReadQuery(queryRef);\n   *\n   *   // ...\n   * }\n   * ```\n   */\n  toPromise<TQueryRef extends PreloadedQueryRef<any, any, any>>(\n    queryRef: TQueryRef\n  ): Promise<TQueryRef>;\n}\n\n/**\n * A higher order function that returns a `preloadQuery` function which\n * can be used to begin loading a query with the given `client`. This is useful\n * when you want to start loading a query as early as possible outside of a\n * React component.\n *\n * > Refer to the [Suspense - Initiating queries outside React](https://www.apollographql.com/docs/react/data/suspense#initiating-queries-outside-react) section for a more in-depth overview.\n *\n * @param client - The `ApolloClient` instance that will be used to load queries\n * from the returned `preloadQuery` function.\n * @returns The `preloadQuery` function.\n *\n * @example\n *\n * ```js\n * const preloadQuery = createQueryPreloader(client);\n * ```\n */\nexport function createQueryPreloader(\n  client: ApolloClient\n): PreloadQueryFunction {\n  return wrapHook(\n    \"createQueryPreloader\",\n    _createQueryPreloader,\n    client\n  )(client);\n}\n\nconst _createQueryPreloader: typeof createQueryPreloader = (client) => {\n  function preloadQuery<\n    TData = unknown,\n    TVariables extends OperationVariables = OperationVariables,\n  >(\n    query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n    options: PreloadQueryOptions<NoInfer<TVariables>> &\n      VariablesOption<TVariables> = {} as any\n  ): PreloadedQueryRef<TData, TVariables> {\n    const queryRef = new InternalQueryReference(\n      client.watchQuery({\n        ...options,\n        query,\n        notifyOnNetworkStatusChange: false,\n      } as ApolloClient.WatchQueryOptions<any, any>),\n      {\n        autoDisposeTimeoutMs:\n          client.defaultOptions.react?.suspense?.autoDisposeTimeoutMs,\n      }\n    );\n\n    return wrapQueryRef(queryRef) as unknown as PreloadedQueryRef<\n      TData,\n      TVariables\n    >;\n  }\n\n  return Object.assign(preloadQuery, {\n    toPromise<TQueryRef extends PreloadedQueryRef<any, any, any>>(\n      queryRef: TQueryRef\n    ) {\n      assertWrappedQueryRef(queryRef);\n      return getWrappedPromise(queryRef).then(() => queryRef);\n    },\n  });\n};\n", "export type { ApolloContextValue } from \"./context/ApolloContext.js\";\nexport { getApolloContext } from \"./context/ApolloContext.js\";\nexport { ApolloProvider } from \"./context/ApolloProvider.js\";\n\nexport { useApolloClient } from \"./hooks/useApolloClient.js\";\nexport { useLazyQuery } from \"./hooks/useLazyQuery.js\";\nexport { useMutation } from \"./hooks/useMutation.js\";\nexport { useQuery } from \"./hooks/useQuery.js\";\nexport { useSubscription } from \"./hooks/useSubscription.js\";\nexport { useReactiveVar } from \"./hooks/useReactiveVar.js\";\nexport { useFragment } from \"./hooks/useFragment.js\";\nexport { useSuspenseQuery } from \"./hooks/useSuspenseQuery.js\";\nexport { useBackgroundQuery } from \"./hooks/useBackgroundQuery.js\";\nexport { useSuspenseFragment } from \"./hooks/useSuspenseFragment.js\";\nexport { useLoadableQuery } from \"./hooks/useLoadableQuery.js\";\nexport { useQueryRefHandlers } from \"./hooks/useQueryRefHandlers.js\";\nexport { useReadQuery } from \"./hooks/useReadQuery.js\";\nexport { skipToken } from \"./hooks/constants.js\";\nexport type { SkipToken } from \"./hooks/constants.js\";\n\nexport type {\n  PreloadQueryFetchPolicy,\n  PreloadQueryFunction,\n  PreloadQueryOptions,\n} from \"./query-preloader/createQueryPreloader.js\";\nexport { createQueryPreloader } from \"./query-preloader/createQueryPreloader.js\";\n\nexport type {\n  PreloadedQueryRef,\n  QueryRef,\n} from \"@apollo/client/react/internal\";\n\n// These types will be removed with v5\nexport type {\n  BackgroundQueryHookFetchPolicy,\n  BackgroundQueryHookOptions,\n  LazyQueryExecFunction,\n  LazyQueryHookExecOptions,\n  LazyQueryHookOptions,\n  LazyQueryResult,\n  LazyQueryResultTuple,\n  LoadableQueryFetchPolicy,\n  LoadableQueryHookOptions,\n  LoadQueryFunction,\n  MutationFunctionOptions,\n  MutationHookOptions,\n  MutationResult,\n  MutationTuple,\n  OnDataOptions,\n  OnSubscriptionDataOptions,\n  QueryHookOptions,\n  QueryResult,\n  SubscriptionHookOptions,\n  SubscriptionResult,\n  SuspenseQueryHookFetchPolicy,\n  SuspenseQueryHookOptions,\n  UseBackgroundQueryResult,\n  UseFragmentOptions,\n  UseFragmentResult,\n  UseLoadableQueryResult,\n  UseQueryRefHandlersResult,\n  UseReadQueryResult,\n  UseSuspenseFragmentOptions,\n  UseSuspenseFragmentResult,\n  UseSuspenseQueryResult,\n} from \"./types/deprecated.js\";\n\n// internal types\nimport type { HookWrappers } from \"./hooks/internal/wrapHook.js\";\n/** @internal */\nexport declare namespace InternalTypes {\n  export type { HookWrappers };\n}\n\nexport const reactCompilerVersion = \"uncompiled\" as string;\n"],
  "mappings": "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",
  "names": ["React", "React", "React", "React", "React", "React", "React", "__use", "React", "React", "React", "realHook", "React", "result", "eagerMethods", "React", "options", "mutation", "client", "result", "React", "observable", "React", "client", "subscription", "React", "React", "from", "cache", "diff", "React", "promise", "options", "variables", "React", "options", "variables", "React", "React", "useWatchQueryOptions", "options", "queryRef", "React", "React", "promise"]
}
